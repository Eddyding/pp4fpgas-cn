{"./":{"url":"./","title":"README","keywords":"","body":"pp4fpga-cn 中文版 Parallel Programming for FPGAs 电子书阅读地址: https://xupsh.github.io/pp4fpgas-cn 电子书下载地址: pdf 写在前面 国内鲜有介绍HLS的书，我们希望通过翻译Parallel Programming for FPGAs这本书，让更多的人来了解HLS和FPGA开发。 翻译之前 Parallel Programming for FPGAs这本书的原作采用的是latex进行内容的编写和排版。为了提高翻译写作的速度和协作的效率，本次翻译任务选择了在GitHub这个平台上进行协作，采用了Markdown使得译者可以专注文字内容而不是排版样式，安心写作。 这也给参与翻译任务的诸位带来了一点小挑战，需要诸位事先熟悉一下GitHub平台的使用、git的使用以及Markdown语言的规范，下面是相关的参考链接给诸位快速上手。 排版约定 排版约定 编辑器 一个界面美观、交互UI设计良好的编辑器可以帮我们节省很多力气，这里我们比较推荐使用以下几款编辑器来进行翻译工作 Atom VS Code Markdown语言 事实上这篇README就是用Markdown写成的 :) 认识与入门Markdown Markdown 语法说明 (简体中文版) git git可以说是现在最为流行的版本管理工具了。 廖雪峰的git教程 猴子都能懂的GIT入门 其实最常用的命令无非下面几条 下载git库到本地 git clone https://github.com/xupsh/pp4fpgas-cn.git 保存本地的修改并上传到云端服务器(GitHub) git add -A git commit -m \"最近的修改里都做了什么\" git pull git push GitHub的Pull Request操作 在GitHub上进行协作，通常采用的方式是先各自fork一份到自己的个人帐户，经过一段时间的工作之后，通过pull request的方式，将自己的工作内容提交到公共项目帐户中，而pull request之后往往还需要进行review才能正式进入公共项目。 github的pull request官方文档 Pull Request 的流程 第一步，你需要把别人的代码，克隆到你自己的仓库，Github 的术语叫做 fork。 第二步，在你仓库的修改后的分支上，按下\"New pull request\"按钮。 这时，会进入一个新页面，有Base 和 Head 两个选项。Base 是你希望提交变更的目标，Head 是目前包含你的变更的那个分支或仓库。 第三步，填写说明，帮助别人理解你的提交，然后按下\"create pull request\"按钮即可。 PR 创建后，管理者就要决定是否接受该 PR。对于非代码变更（比如文档），单单使用 Web 界面就足够了。但是，对于代码变更，Web 界面可能不够用，需要命令行验证是否可以运行。 任务分工 见Wiki页面 Citation https://github.com/KastnerRG/pp4fpgas @ARTICLE{ 2018arXiv180503648K, author = {{Kastner}, R. and {Matai}, J. and {Neuendorffer}, S.}, title = \"{Parallel Programming for FPGAs}\", journal = {ArXiv e-prints}, archivePrefix = \"arXiv\", eprint = {1805.03648}, keywords = {Computer Science - Hardware Architecture}, year = 2018, month = may } Copyright © xupsh.github.io 2018 all right reserved，powered by Gitbook 该文件修订时间： 2018-06-18 15:09:08 "},"00-Preface.html":{"url":"00-Preface.html","title":"前言","keywords":"","body":"前言 \"当有人说‘我想要一个编程语言，这个语言我只需要直接写我要干什么’的时候，你还是给他一个棒棒糖吧。\" -Alan Perlis 本书将着重介绍高层次综合（HLS） 算法的使用并以此完成一些比较具体、细分的FPGA应用。我们的目的是让读者认识到用HLS创造并优化硬件设计的好处。当然，FPGA的并行编程肯定是有别于在多核处理器、GPU上实行的并行编程，但是一些最关键的概念是相似的，例如，设计者必须充分理解内存层级和带宽、空间局部性与时间局部性、并行结构和计算与存储之间的取舍与平衡。 本书将更多的作为一个实际应用的向导，为那些对于研发FPGA系统有兴趣的读者提供帮助。对于大学教育来说，这本书将更适用于高阶的本科课程或研究生课程，同时也对应用系统设计师和嵌入式程序员有所帮助。我们不会对C/C++方面的知识做过多的阐述，而会以提供很多的代码的方式作为示范。另外，读者需要对基本的计算机架构有所熟悉，例如流水线（pipeline），加速，阿姆达尔定律（Amdahl's Law）。以寄存器传输级（RTL)为基础FPGA设计知识并不是必需的，但会对理解本书有所帮助。 本书囊括了很多对教学很有帮助的内容。每个章节均有一些小问题留给读者，这些问题将有助于加深对于材料的理解。在加州大学圣地亚哥分校（UCSD）的CSE 237C这门课里也有很多用HLS开发的项目，如果有出于教育目的的需要，我们可以对提出申请的读者分享这些课程项目的文件。这些HLS项目主要是与数字信号分析相关，重点于无线交流系统的开发。每个单独的项目都或多或少与书中的某一章节有所关联。这些项目以赛灵思大学计划（Xilinx University Program）使用的FPGA开发板为基础而开发，设计基础参考 http://www.xilinx.com/support/university.html 。赛灵思也同时提供这些开发板的商业订单。同时我们鼓励读者在 http://xilinx.com 申请Vivado HLS的试用许可。 本书并不着重于HLS算法本身。HLS处理方面的具体内容已经有很多的资源供读者参考，包括计划，资源分配，捆绑[51, 29, 18, 26]的算法。 本书更多的将会是引导学生掌握各类算法怎样分明的协同工作，提供具体的HLS语言开发程序的使用案例，因此，其他的一些更注重于算法与概念本身的材料会对理解本书很有帮助。本书也不着重于FPGA的细分结构和RTL设计方法，但是同样这方面的材料可以作为很好的辅助材料。 本书将主要使用赛灵思的Vivado HLS来完成类C代码到RTL的转换，C语言下的示例是针对Vivado HLS语法而完成的。本书不仅将介绍Vivado HLS的具体使用，而且会介绍那些最基本的HLS概念，这些概念应当适用于所有开发工具。我们同时鼓励读者尝试其他工具以真正理解这些概念，而不仅仅是在我们使用的工具里“学会”如何一步步操作。 希望你能享受这本书，并祝一切好运。 Copyright © xupsh.github.io 2018 all right reserved，powered by Gitbook 该文件修订时间： 2018-06-18 15:09:08 "},"01-Introduction.html":{"url":"01-Introduction.html","title":"第一章","keywords":"","body":"第一章 介绍 1.1 高层次综合（HLS) 硬件设计与处理近几年来发展迅速。 过去我们的电路相对简单，硬件设计师们可以很方便的画出每一个晶体管，规划他们的连接方式，甚至他们的板上位置。可以说所有工作都是人工完成的。但随着越来越多晶体管的设计需要，硬件工程师也越来越需要依赖自动化设计工具来帮助他们完成设计，而这些设计工具也相对应的变得越来越精密。工程师在这些设计工具的协助下也更具效率。他们不再具体操作每一个晶体管，而只需要设计数字电路，电子设计自动化工具（EDA）把这些抽象而概括的电路自动转换成实际的部件构造版图。 米德和康威（Mead&Conway）的方法[50]，也就是使用一种硬件语言描述语言（Verilog, VHDL），并把其编译成片上设计的方法在上世纪80年代开始广为使用。但这之后硬件的复杂度还在以指数函数的增长速度发展，硬件工程师们只好寻求更加概括而高层的编程语言，RTL应运而生。在RTL里，设计师不需要考虑怎么构造一个寄存器或怎样安置这些寄存器，而只需要考虑这些寄存器在设计中起到怎样的作用。EDA工具可以先把RTL转化成数电模型，再由模型转换成一个设备上的具体电路实施方案。所谓“方案”其实就是编译出的文件，这些文件可以用于规定某个自定义设备，也可以用于编程一些现有的设备，比如FPGA。如我们现在所见，新的设计方法确实帮助工程师们的设计思路变得更加清晰。更多关于这方面的探讨参考注释[42]. HLS则是在这基础上更高层的一种方法，设计师们在HLS下需要更多的考虑大的架构而非某个单独部件或逐周期运行。设计师在HLS下需要注重的是系统的运行模式，HLS工具会负责产生具体的RTL微结构。最早大多数HLS工具是基于Verilog的，用户需要使用Verilog语言进行描述，工具也通过Verilog产生RTL。现如今很多HLS工具开始使用C/C++作为设计师端的语言。当然，选择HLS工具最重要的还是看它能否综合我们需要的程序，而不是它使用什么语言。 总体来说，HLS可以自动完成以下曾经需要手动完成的工作： HLS自动分析并利用一个算法中潜在的并发性 HLS自动在需要的路径上插入寄存器，并自动选择最理想的时钟 HLS自动产生控制数据在一个路径上出入方向的逻辑 HLS自动完成设计的部分与系统中其他部分的接口 HLS自动映射数据到储存单位以平衡资源使用与带宽 HLS自动将程序中计算的部分对应到逻辑单位，在实现等效计算的前提下自动选取最有效的实施方式 HLS的目标是根据用户提供的输入和限制自动替用户做出很多决定。每个HLS工具在实际施行的效率上相差甚远，这其中我们有一些非常不错的选择，例如赛灵思Vivado HLS, LegUp, Mentor Catapult HLS。他们出众的特性在于可以支持更多更广泛的程序转换。我们在本书中将使用Vivado HLS作为演示软件，但是设计的思路与技巧在各个软件中应当是通用的，读者只需要在各自的软件中对语法进行稍微的调整。 大多数HLS工具需要用户提供功能的规范，交互的描述，一个对接的计算设备，和目标优化方向。而对于Vivado HLS来说，用户需要： 一个用C/C++/System C编写的函数 一个测试平台用于验证结果 一个FPGA开发版 期望的时钟周期 一个简单的实施指导 HLS工具没有强大到可以处理任何代码。很多我们平时在软件编程中常用的概念在硬件实施中很难实现，所以硬件描述语言对于具体实施会更加灵活。通常这些HLS工具需要用户提供一些附加信息（通过suggestion或#pagma）来帮助完善程序，因此我们说HLS工具会同时“限制”又“加强”了一门语言。举例而言，HLS工具一般无法处理动态内存分配，大部分工具对标准库的支持也非常有限。用户也应当避免系统调用和递归以尽量降低复杂程度。除去这些设计限制之外，HLS工具的处理范围非常的广（包括直接内存访问，流，片上内存），优化效率也很高。 根据Vivado HLS的使用指南，我们将对我们的输入程序作出以下规范： 不使用动态内存分配（不使用malloc(),free(),new和delete()） 减少使用指针对指针的操作 不使用系统调用（例如abort(),exit(),printf()），我们可以在其他代码例如测试平台上使用这些指令，但是综合的时候这些指令会被无视（或直接删掉） 减少使用其他标准库里的内容（支持math.h里常用的内容，但还是有一些不兼容） 减少使用C++中的函数指针和虚拟函数 不使用递归方程 精准的表达我们的交互接口 当RTL级的设计可用时，大多数HLS工具会进行标准RTL设计流。而在赛灵思Xilinx Vivado设计套装里进行的是逻辑综合，将RTL级设计转换成一个FPGA逻辑部件的连线表，这份连线表不仅包含需要的逻辑部件还包含他们的连接方式。Vivado之后将连线表和目标设备中的可用资源相关联，这个过程被称作布局及布线（PAR）。产出的FPGA配置被附在比特流（bitstream）上，用户可以将比特流上传到FPGA以实现想要的功能。比特流实质上是用二进制表示FPGA上每一个可用资源的配置，包括逻辑部件的使用，连线的方式，和片上的内存。大型FPGA例如赛灵思UltraScale FPGA拥有超过十亿个可配置比特，较小的FPGA上也至少有几亿个可配置比特。 1.2 FPGA构造 了解HLS的第一步是熟悉FPGA的构造，因为很多HLS的优化都是和这些构造特点息息相关的。过去几十年来，FPGA变得越发大而复杂，也加入了片上内存、自定义数据路径，高速I/O，和多核处理器等等精密结构。在这一节，我们只讨论FPGA中与HLS相关的结构特点，其他无关内容不会被详细描述。了解FPGA的现代结构后再学习HLS会有助于读者对于其理解。 FPGA由一个可编程逻辑模块的矩阵和与之相连的内存组成，通常这些模块是以查找表（LUT）的形式存在，也就是说把地址信号输入进去，对应内存位置的内容会直接被输出出来。一个N位查找表可以以一个N位输入真值表的方式来表示。 上图中的a部分是一个2位输入查找表，共有22{2}^{2}22个配置比特。使用者通过编写程序来控制这些比特以实现某种功能。b部分是一个2位输入AND门的真值表，通过对应4个可能的结果产出（out一列），我们可以把a中的2位查找表编写成b中的AND门，即四个查找表输入依次对应b中的00，01，10，11。按照这个模式编写查找表，我们可以轻松的改变它的功能，让它充当我们需要的部件。对于小的布尔逻辑（Boolean），这样的编写方式更加的灵活高效。实际中的FPGA大多使用4-6位输入的查找表作为运算基础，一些大型FPGA内甚至有几百万个这一级别的查找表。 怎样将图片1.1中的查找表编写成一个XOR门呢？一个OR门？我们需要一个几位输入的查找表？ 一个2位输入的查找表最多可以被编写出多少种形态？一个n位输入的查找表呢？ 触发器（FF）是FPGA最基本的内存单位，通常触发器是配有查找表的，这样是为方便查找表之间的复制与组合。在这基础上再加入一个规定它们的函数（例如全加器），就可以创建一个更为复杂的逻辑单位，称为可配置逻辑块（CLB）或逻辑矩阵块（LAB）。有些设计工具中还会把它称作片（Slice）。为避免歧义，我们将在下文中用slice作描述，这样读者可以对在Vivado设计工具中出现的Slice更加熟悉。一个slice是几个查找表，触发器，和多路复用器（MUX）组合到一起而形成的更强大的可编程逻辑单位。每个slice需要的小部件数视FPGA的架构而变，但总体来说每个slice真的只包含不多的几个部件。图片1.1中的c部分就是由1个三位输入查找表和1个触发器组成的slice。slice可以变得更加复杂一点，比如常见的全加器。FPGA内部通常有一些定义好的全加器slice，这看起来有点违背FPGA的“可编写性”。但实际上使用全加器在硬件设计中太过于常见，把所有的全加器每次重新编写成一个slice会降低效率。灵活性和高效综合考虑，一些被配置好的slice是一个对整个系统有益的设计。 可编写的互联是FPGA最关键的特性之一，它能提供一个slice之间更灵活的连线网络。slice的输入与输出全都与连线通道相连，连线通道也是通过配置比特来决定每个slice的输入输出通向哪里，而通道本身则与开关盒相连。开关盒由很多传输晶体管充当的开关所组成，它的工作便是连接通道与通道。 图片1.2展示了一个slice，连线通道和开关盒之间的连接方式。slice的每个输入输出都应与通道中的一条路线相连。所谓路线，我们可以简单的把它想成一跟比特层级的跳线，在物理层级上这条线路是由传输晶体管构成的，同样具有可编写性。 开关盒像是一个连接矩阵，沟通不同连接通道中的各个路线。FPGA一般有一个2D的形式，能给使用者一个大概的2D计算模型，我们称之为岛状结构。在岛状结构里，每个slice都是一个逻辑岛，岛与岛之间通过连线通道和开关盒相连。在这里每个开关盒在上下左右四个方向连接了四个连线通道。 连线通道和开关盒中的所有开关都通过使用者的编写控制着逻辑部件之间的联系。现如今业界对于电路层级的FPGA架构已经了解的很深了，连线通道的数量，开关盒的连接方式，slice的结构等等都有很详尽的资料。我们在注释中附上了一些书籍[12, 10, 30]，有兴趣的读者可以参考一下。当然使用HLS工具不需要了解那么多细节的资料，这方面更多的知识是作为理解HLS优化工作的辅助。 图片1.3提供的是一个更概括性的结构互联，可以比较清楚的看到各部分之间的物理连接方式。FPGA的逻辑部分通过一些IO模块与外部设备相联系，像微控制器（通过AXI接口连接片上ARM处理器 ），传感器（通过A/D接口连接天线），作动器（通过D/A接口连接电机）都是可以实现的。近来发展的FPGA又集成了自定义片上I/O处理器，像内存控制，无线收发，模拟与数字转换器这类的装置。 我们说到FPGA上要承载的晶体管变得越来越多，这也是FPGA上多了很多预配好的资源的原因。这部分硬件用于完成特定工作。很多设计都需要大量的加法和乘法，因此FPGA厂商把这部分的内容预配好以直接使用。像DSP48数据路径已经被用一种高效的方法预配好，添加了乘法、加法、乘积、逻辑操作等一系列算数。对于DSP48这样的模块来说，它们依旧保留了一定的可编写性，但不想其他可编程逻辑那样完全灵活。这样综合而言，用户在DSP48这样的模块上进行乘法这样的操作会比重新编写高效的多。所以我们说灵活性和效率有时候是此消彼长的。现代FPGA会含有成百上千个DSP48模块，如图1.4所示。 比较自搭乘积和DSP48基础上乘积的性能，两种情况下可获得的最高频率分别是多少？FPGA资源利用上有什么变化吗？ 块RAM（BRAM）是另一个预配好的模块。BRAM是一个支持多种内存形式和接口的可配置随机储存器，可以储存字节，对字，全字，双字等等等。BRAM还可以把这些数据传给本地片上总线（与可编程逻辑交流）或处理器总线（与片上处理器交流）等等接口。总体来说它有两个功能，一是芯片上各部分的数据转移，二是储存大一些的数据集。slice经过编写也可以储存数据（通过触发器），但这样做会增加额外消耗。 外部内存 BRAM 触发器 数量 1-4 几千 几百万 单个大小 GB级 KB级 比特级 总量 GB级 MB级 几百KB 宽度 8-64 1-16 1 总带宽 GB每秒 TB每秒 几百TB每秒 表格1.5:三种形式内存存储比较。外部内存存储密度最高但带宽有限，触发器拥有最好的带宽但储存容量太小，BRAM则像是两者之间的中间值。 一块BRAM通常有大约32000比特的储存容量，可以以32000 x 1比特，16000 x 2比特，8000 x 4比特等等形式存在。串联在一起可以拥有更大的容量，Vivado工具可以完成这方面的配置，而Vivado HLS的优势也在于这里，设计者不再需要考虑这一层级的细节。通常BRAM和DSP48放置在一起，对于HLS设计来说，我们可以直接把BRAM想成一个寄存器堆，它可以直接输出到一个自定义的数据路径（DSP48），可以与处理器交流，也可以像可编程逻辑上的数据路径传输数据。 思考怎样把一个很大的数组存在BRAM和可编程逻辑里。它的性能如何变化？资源使用呢？ 表格1.5是一个不同内存形式比较的表格。如表格所示，所有触发器最后可以形成一个几百KB的储存，它们每个周期都可以被读写所以总带宽非常的大，但很显然他们的储存容量不尽如人意。BRAM在不牺牲很大带宽的前提下，提供了更大的储存密度。带宽的牺牲主要在于每个周期BRAM只有1-2个入口可以被接通。外部内存对于带宽的牺牲更大，但提供了最大的容量。把应用数据放在哪里是非常关键的一个设计决定，我们会在整本书里经常提到。Vivado HLS工具也允许设计者清楚指明到底要将这段数据放在哪里。 片上晶管的繁多也丰富了我们的预配资源，片上的处理器其实就是一个很好的代表。现如今的高端FPGA会含有4个甚至更多的微处理器（比如ARM核心），小型的FPGA上附有一个处理器也变得很常见。处理器使芯片有了运行操作系统（比如Linux）的能力，它可以通过驱动和外部设备交流，可以运行更大的软件包比如OpenCV，可以运行更高级的语言（比如python）并以更快的速度运行。处理器经常成为了整个系统的控制者，协调了各方之间的数据转移，也协调了各个IP核心（包括用HLS自定义的IP核和第三方IP核）和板上资源的关系。 1.3 FPGA设计与处理 由于FPGA大小和复杂度的不断提升，设计师更倾向于从高层建造自己的设计。这样一来，FPGA设计更多是由一个个大组件，或IP核组建而成，如图1.6。在整个设计的外围临近I/O引脚的地方通常是一些少量的逻辑，它们一般用来完成关键时序和协议，比如内存控制模块，视频接口核心或模拟数字转换器。这部分逻辑我们称之为I/O接口核，通常以RTL的形式构架并需要加上其他的时序限制。时序限制的目的是阐明信号本身与信号变化规则之间的时序关系。设置限制的时候必须要考虑信号蔓延到电路板和连接装置的影响。使用I/O引脚附近逻辑的考虑是为了高速接口的实施需要，这些逻辑更适合在“高速”前提下实现数据的序列化和反序列化，时钟的恢复与分布，和精准延迟某些信号以不断从寄存器获取数据。I/O接口核心在不同的FPGA架构上差别比较大，FPGA供应商一般会有设计参考或成品部件，因此我们不会展开太多细节。 除了I/O引脚，FPGA一般会有标准核，处理器核心，片上内存核连接开关都属于标准核。标准核另外还包括原生的函数处理部件比如滤波器，FFT，编解码器等等。这些核心的参数和接入方式在不同的设计中相差很大，但它们并不是在设计中真正造成差异的部件，相反他们是相对“水平的”技术部分，可以被插入到各类不同的应用领域。FPGA厂商同样也提供这些模块，但设计师其实很少情况下接触到它们。不像IO接口核心，标准核心主要是同步电路，它除了时钟时序限制之外不大有限制。这些特点让标准核更容易在不同FPGA中兼容，当然，被转移到另一种FPGA结构中时还是需要一定优化的。 最后一种核心是针对应用的加速器核，同标准核一样，加速核通常是由时钟限制而规定的同步电路，但这些核却是系统设计师们在具体应用中不可避免要接触的部分。如果把一个设计的系统比做一道菜，那加速器核就像是秘制配方，它是让每个人的菜肴各有风味的关键。最理想的情况是设计师又快又轻松地设计出了这样的高性能核然后把它们以很快的速度集成到整个系统里，这也是我们这本书的主要目标，用HLS设计出快而高效的核。 图片1.6中的系统通过两种方法可以实现。第一种方法是把HLS产生的加速器核当作一个普通的核。用HLS创造出这种核之后把他们与IO接口核和标准核组合到一起（可以通过Vivado IP Inegrator这样的软件），这样我们就得到了完整的设计。这个方法叫做以核为基础的设计方法，与使用HLS之前的FPGA设计方法十分相似。第二种方法则着重于设计样板或平台，称为平台为基础的设计方法，这种方法下设计师先用IO接口核和标准核组合出一个样板，然后再用HLS通过壳（shell）的接口将各式算法或对象组合进去。只要壳支持双边的接口，加速器核在平台与平台之间的移动也非常容易。 1.4 设计优化 1.4.1 性能特点 在开始讨论怎么去优化之前，我们先要讨论一下判断一个设计特点的标准。计算时间就是一个衡量设计好坏的重要标准。很多人把时钟周期数作为一个同步电路性能的指标，但实际上对于两个使用不同时针的电路这是不得当的，而时针不同又是HLS下的绝大多数情况。比如说，我们现在已经规定好了Vivado HLS的输入时钟限制，那么工具根据时钟的不同会从同一段代码中产生不同的结构，所以这不是一个很恰当的比较方式。秒数是一个更好的对应比较指标。Vivado HLS工具会提供一个周期数和周期频率的报告，用户可以用此得出某段代码的操作时间。 改变时钟频率有时候可以优化设计。Vivado HLS工具把时钟频率作为一个输入，所以改变一个输入可以导致产出的结构完全不同。我们会在后文继续讨论。书中章节2.4描述了根据时钟周期决定限制。书中章节2.5讨论了改变时钟周期如何通过操作链提升产力。 我们用任务（task）这个术语来表示一个行为的基本单位，用户可以在Vivado HLS中发现与之对应的是调用函数。任务延迟就是任务开始到任务完成中间的这段时间。任务间隔则是任务开始到下一个任务开始之间的这段时间。所有的任务输入，输出和计算的时间都被算在任务延迟里，但是任务的开始并不等同于读取输入，同样任务的结束也不等同于写出输出。在很多设计中，数据率是一个很重要的东西，它同时取决于任务间隔和函数参数的多少。 图片1.7表示的是两种设计的实施设想，横向轴是时间轴（从左到右增大），纵向是设计中不同的函数单位。红色表示的是输入有关的操作，橙色表示的是输出有关的操作，正在活跃的运算符用深蓝表示，不活跃的则用浅蓝表示。每一个进入的箭头表示的是一个任务的开始，而出去的箭头表示任务的完成。左侧的图表示的是一个每个周期都执行新任务的结构设计。与之对应的是完全流水（fully-pipelined）结构。右侧表示的则是一个完全不一样的结构，系统每次读取四段输入，处理数据，然后再合成一个4段数据的输出。这种结构的任务延迟和任务间隔是一样的（13个周期），并且每一周期内只有一个任务在执行。这个结构和左边的流水形成了鲜明对比，左边的结构在同一周期内显然有多个任务在执行。HLS中的流水和处理器中的流水概念相似，但是不再使用处理器中操作分5个阶段并把结果写入寄存器堆的方法，Vivado HLS工具构造的是一个只适用于特定板子，可以完成特定程序的电路，所以它能更好的调整流水的阶段数量，初始间隔（连续两组数据提供给流水之间的间隔），函数单位的数量和种类，还有所有部件之间的互联。 Vivado HLS工具通过计算一个任务输出到输入之间这个过程需要的寄存器数来决定周期。因此，0周期的任务延迟是可以实现的，也就是组合逻辑下路径上没有任何寄存器。另一个常用的工作是计算输入输出并把结果存到寄存器里，通过这些数据找到路径上的寄存器数。这样的计算有花费很多的周期。 很多工具把任务间隔称为生产力（throughput）。这个词语听起来和间隔没什么关系。一个任务间隔的变长不可避免的会减少一段固定时间内能完成的任务数，也就是“生产的力度”。还有一些工具用延迟来描述读输入和写输出的关系。非常不幸的是，在一些复杂的设计中，任务的特点很难仅仅用输入输出来分析，比如有时候一个任务需要读很多次数据。 1.4.2 面积和产力的取舍 为了更深入的讨论使用HLS工具过程中的问题，我们需要分析一个简单但很常见的硬件函数——有限脉冲响应（FIR）滤波器。FIR会对输入做固定系数下的卷积，它可以被用作充当各式滤波器（高通，低通，带通），最简单的FIR可能就是一个移动平均滤波器。有关FIR的具体内容会在第二章展开，在这里我们从高层简要的谈一下。 #include \"stdio.h\" #define NUM_TAPS 4 void fir(int input, int *output, int taps[NUM_TAPS]); const int SIZE = 256; int main() { int taps[] = {1, 2, 0, -3, 0, 4, -5, 0, 1, -2, 0, -3, 0, 4, -5, 0}; int out = 0; for (int i = 0; i （代码样例）图片1.8:四抽头FIR滤波器的代码. 图片1.8中的C代码可以作为一个HLS的任务描述。这段代码可以直接作为Vivado HLS工具的输入，工具会自动分析并产生一个等效的RTL电路。这个过程具体细节比较复杂，我们暂时不做深究，只需要把它当作一个编译器去理解，像是gcc，只不过这个编译器输出的是RTL硬件描述。编译器的复杂性是它非常关键的原因之一，因为它不需要用户理解每一个细节。但理解编译器如何工作其实有助于设计师写出更高效的代码，这点对于HLS尤其重要，因为综合电路的构建方式有很多种，只理解它软件流是不够的。比如HLS设计师需要考虑流水，内存排布，I/O接口这些软件设计师不需要考虑的内容。 回到编译器，理解它的关键问题在于：这段代码中产生的是什么电路？这个问题的答案分多钟，还和你所用的HLS工具有关。那么通常工具有以下几种合成方式： 第一种可能的产出电路是按照顺序执行每行代码产出的电路，这时候工具就像一个简单的RISC处理器。下面的图片1.9中的代码是图片1.8中的代码在赛灵思Microblaze处理器下的汇编代码版本。虽然已经经过了优化，但还是有很多指令用来执行计算数组索引（array index）和控制循环。这样的指令我们假设它每个循环都要执行一次，那么我们在49个循环之后才能得到滤波器得出的结果。我们可以很明了的得到一个结果，那就是一个周期内执行的指令数是影响性能的一个重要的壁垒。有时候对于一个架构的提升就是让它处理的指令变得更复杂，让同一个指令能做的事情变得更多。HLS的一个特点就是在决定结构上的一些此消彼长的设计时，不再需要考虑让它适用于指令集的结构限制。在HLS设计中，设计出一个在同周期内执行成百上千个RISC级指令外加几百个周期程度流水的系统是非常常见的。 fir: .frame r1,0,r15 # vars= 0, regs= 0, args= 0 .mask 0x00000000 addik r3,r0,delay_line.1450 lwi r4,r3,8 # Unrolled loop to shift the delay line swi r4,r3,12 lwi r4,r3,4 swi r4,r3,8 lwi r4,r3,0 swi r4,r3,4 swi r5,r3,0 # Store the new input sample into the delay line addik r5,r0,4 # Initialize the loop counter addk r8,r0,r0 # Initialize accumulator to zero addk r4,r8,r0 # Initialize index expression to zero {% math_inline %}L2: muli r3,r4,4 # Compute a byte offset into the delay_line array addik r9,r3,delay_line.1450 lw r3,r3,r7 # Load filter tap lwi r9,r9,0 # Load value from delay line mul r3,r3,r9 # Filter Multiply addk r8,r8,r3 # Filter Accumulate addik r5,r5,-1 # update the loop counter bneid r5,{% endmath_inline %}L2 addik r4,r4,1 # branch delay slot, update index expression rtsd r15, 8 swi r8,r6,0 # branch delay slot, store the output .end fir 这是Vivado HLS默认下产出的是非常顺序化的结构。所谓顺序化的结构，是指循环和分支都被写作控制逻辑以控制寄存器、功能单元等部件。这其实和RISC处理器的概念相同，除了我们提到过产出的结果是RTL结构下的状态机。这种结构更倾向于限制那些使用资源去并行的功能单元。顺序化结构可以从大多数程序中生成，无需对原代码做太多的修改和优化，所以对HLS初学者非常的简单。但它同样存在一些缺陷。顺序化的结构很难解析码流，主要出于控制逻辑的复杂度。另外，控制逻辑负责规定任务延迟和任务间隔。顺序化结构的性能有时取决于处理的数据。 Vivado HLS可以产出更加流水，平行，性能上也更好的结构。其中之一叫做函数流水。函数流水结构是把函数内所有的代码都当作计算数据路径的一部分，再加上少量的控制逻辑。循环和分支被转换成无限制的结构。这种结构特点分明，容易分析，一般用于处理连续而简单的高码率数据。函数流水结构可以在更大的设计中充当组件，因为它的行为比较简单，方便共享资源，但这种结构的缺点在于适用范围相对较小，不是所有代码都可以被设计成平行结构。 用户可以通过在代码中添加#pagma HLS pipeline来指导Vivado HLS工具产生函数流水结构。这段指令需要一个参数来规划流水的起始间隔，也就是一个函数流水的任务间隔。图片1.10展示了一个可行的设计——每周期一抽头的架构。任务用到了一个乘法器和一个加法器完成滤波器。这种设计的任务间隔和任务延迟都是4个周期。图片1.11展示的是一个每周期一样本的结构，它使用了4个乘法器和3个加法器。这种设计的任务延迟和任务间隔都是1个周期，所以它每个周期都接受一个新的输入。当然这两种之外还有很多可行的设计，比如每周期两抽头设计，或每周期两样本设计，在一些特定应用中各自有各自的优势，我们将在第二章中讨论更多优化。 实际应用中，复杂的设计在顺序化和并行化的结构之间会有很多取舍的考虑。这些取舍在Vivado HLS中很大程度上取决于设计者的决定和代码内容。 1.4.3 处理速率的限制 我们看到了很多改变架构会改变任务间隔的例子，这样做通常来讲可以提升处理速率。但是读者需要意识到任何结构的任务间隔都是有一定的限度的。最关键的限制来自于递归和反馈循环，还有一些其他的例如资源限制也很重要。 递归（recurrence），这里是指某个部件的计算需要这个部件之前一轮计算的结果， 递归是限制产力的重要因素，即使在流水结构中也是如此[56，43]。分析算法中的递归并产出正确的硬件设计是非常关键的一步，同样，选择一个尽量避免很多递归的算法也是设计中非常关键的一步。 递归在很多代码结构中都会出现，比如静态变量（图片1.8），顺序的循环（图片1.10）。它存在于很多顺序化结构中，也有很多会随着改编成流水结构而消失。对于顺序化结构递归有时候不影响处理速率，但是在流水结构中是一个很不理想的状况。 另一个影响速率的关键因素就是资源限制，其中一种形式是设计边缘的跳线，因为一个同步电路中的每根跳线在每周期只能传送抓取1个比特的数据。因此，如果 int32_t f(int32_t x)这样形式的函数作为一个单独模块在100MHZ的频率和1的任务间隔下运行，它最大的数据处理量就是3.2G比特。另一种资源限制来自于内存，因为大多数内存每周期只支持一定次数的访问。还有一种资源限制来自于用户所给的限制，如果用户规定了在综合中可用的操作数，这其实是给处理率添加了限制条件。 #define NUM_TAPS 4 void block_fir(int input[256], int output[256], int taps[NUM_TAPS], int delay_line[NUM_TAPS]) { int i, j; for (j = 0; j 0; i--) { #pragma HLS unroll delay_line[i] = delay_line[i - 1]; } delay_line[0] = input; for (i = 0; i （代码样例）图片1.12：另一种FIR滤波器代码 1.4.4 代码风格 每个工程师在设计时都该问自己：我写的这段代码有最好的利用算法吗？在很多情况下，我们追求的不是结果质量达到极致，而是代码更易于更改更灵活。虽然这其实是个因人而异的风格问题，但有些代码风格确实会限制HLS工具产出的结构的质量。 举例而言，在不同的工具中输入图片1.8的代码，图片1.10和图片1.11都是可能的产出结果。但是加入了图片1.12中的那些指令之后就会一定产出特定的一种结果。这个情况下延迟线被展开，乘积的for循环都被用流水的方式实施，产出的结构会于图片1.11中的结构相似。 本章介绍了很多不同处理率的方法，其中最快的甚至到了每周期一样本的结构。但是，还有很多的应用需要更高的处理率，比如每周期多个样本。这样的设计需要怎样的代码呢？以设计一个每周期四样本的FIR滤波器为例，这样的设计需要多少资源（加法器和乘法器的数量）？与每周期一样本相比哪个资源使用更多？ 我们将会在第二章具体讨论每种优化怎样影响性能和资源使用。 1.5 重建代码 写出一个非常优化的HLS代码不是一两步就可以完成的工作，设计者必须对程序的应用有很深的理解，才能让HLS工具利用指令产生最高效的结构。 在这本书接下来内容里，我们会以应用为主题，讨论几个常见应用的综合的过程，包括数字信号处理，排序，矩阵操作，视频处理。理解算法是非常重要的一步，因为对代码的调整经常不止于加几句指令，有时候还需要重写整段。 重建代码，对于工具链来说经常变成很难读懂的行为，需要与硬件对应好关系，所以它不仅要求对算法的理解还要求对硬件微结构有比较深的理解。一般来说现成的算法原代码产出的结构比普通的CPU程序还低效，即使使用流水，展开等方法也没起到太大的作用。所以最好的方法还是自己写出一个等效但适合高层次综合的算法。 重建代码与它原来的软件版本通常区别很大。一些研究指明重建是提升效率的非常重要的一步[46,47,15,14,39]。用户在写重建代码时一定要时刻分析潜在的硬件设计。 在本书接下来的内容里，我们会展示之前提到的几个应用程序用于产出硬件结构的代码，具体包括FIR，离散傅里叶变换（DFT），快速傅里叶变换（FFT），稀疏矩阵乘矢量（SpMV)，矩阵相乘，排序，哈夫曼编码。我们会讨论重建代码对最终硬件结构的影响，具体来说，针对每一章我们计划： 强调重建代码对于高质量设计的重要性，比如在高性能和低使用面积上。 对常见的内容提供重建的代码 讨论重建对于硬件的影响 使用必要的HLS指令以实现最好的设计 整本书来说，我们的示例会引导读者从最基础的设计到更有效的设计，因为我们相信理解来自于对示例的研究。每一章会采用不一样的优化策略，包括流水，数据流，循环优化，数组分离，带宽优化等等。另外，我们也会提供对于重建代码必要的洞察训练和知识。 1.6 本书结构 就像我们之前所说的，这本书的宗旨是以示例教学。每章将展示一个应用，逐步构建HLS，并一层层的优化。每章都只会用到一小部分优化策略，每章内容的难度也是逐步增加的。第二章我们会分析相对简单的FIR滤波器，而到了第九章我们会分析复杂的视频处理系统。 我们这样的教学方法当然也是会有弊有利，我们认为好处主要体现在 ： 1）读者可以清晰的看到优化是如何具体实施的 2）每一章都会展示怎么具体的写HLS代码 3） 有些应用解释起来比较简单，但实际实施却是另外一回事，简单不完整的示例经常不够读者学习。 相对的，缺点主要在于：1）大多数应用还是要求读者对计算和背景有一定的理解，而真正理解计算部分又有时需要比较深的数学背景。例如，FFT的最好结构需要读者深入理解DFT和FFT的数学背景。出于这个原因，有一些章节（比如第四章DFT第五章FFT）以一些数学介绍为开头。有些读者认为这些数学知识对于具体实施HLS没什么帮助，但我们认为这部分内容对于代码重建是非常必需的。 2）有时候一件没那么具体的示例其实能更好的概括代码，具体示例中细枝末节反而会让读者很疑惑。 每章的结构大致相同，一般会以一些必要的背景介绍开始。对于大多数章节程序的背景介绍没有程序本身听上去那么复杂，比如第七章矩阵相乘，但是还是有例如第四章DFT这样的章节我们会介绍大量的数学知识。介绍之后我们会提供一个基准方法——一个不经过任何优化但是结果正确的HLS构建方法。然后我们就会开始介绍不同的优化。每章内容包含的优化内容也有多有少，像第三章只比较强调带宽，第二章就描述了很多优化方法。一些非常关键的优化策略会贯穿全书被多次提到。 我们建议读者按顺序阅读本书。像我们在第二章会介绍后面出现的大多数优化策略，然后在后续的章节才会对其中的一些策略深入讲解。还有应用的难度也是逐渐增长的。但其实从各应用本身的内容上来说，各章交叉不大，所以如果读者已经是一个比较有经验的HLS设计师，那么完全可以根据需要只读某几章某一章。比如说第十章排序，读者如果已经有一定的HLS基础就不需要从头开始读这本书。 下面的表格1.1提供了一个各优化的总览表，读者可以看到每章使用了哪些优化，其中第二章除了各种对于FIR滤波器的优化之外，还简单的介绍了一下HLS的设计过程。总体来说后面的章节会更注重某几个优化并详细介绍。 章节 FIR CORDIC DFT FFT SpMV 矩阵 直方图 视频 排序 哈夫曼 展开循环 x x x x x x 循环流水 x x x x x x x x 带宽优化 x x x 函数内嵌 x x 分层 x x x x x x 数组优化 x x x x x x x x 任务流水 x x x x x 测试平台 x x x x 一同仿真 x 实时计算 x x x 接口交互 x 表格1.1:一个优化策略和章节的对照表 第三章到第五章可以算作一个系列，这个系列着重于建造数字信号处理模块（CORDIC，DFT，FFT）。这些章节都侧重于某一个优化策略，比如第三章的带宽优化，第四章的数组优化，第五章的数组优化和任务流水。以第四章DFT为例，第四章介绍了数组优化，特别介绍了怎样利用数组分离来提升片上内存带宽。这一章也提到了展开循环和循环流水，并且讲述了让这些优化共存的方法。 第五章描述了快速傅立叶变换的优化，它其实本身就是DFT的一个重构代码。FFT本身就是一个阶段化很明显的算法，所以非常适合任务流水。最终版优化代码需要一些其他优化包括循环流水，展开，数组优化等。每一章其实都在附录中的项目有所关联，他们最终的集成到一起可以组成一个无线交流系统。 第六章到第十一章对更多的应用做出了讲解。第六章讲述了如何使用测试平台和RTL同仿真，还讨论了一下数组和循环的优化。这些基本的优化策略很常见，在大多数程序中都有使用。第七章介绍了数据流的实时计算这个策略。第八章展示了两种应用（前缀和，直方图），这两个应用本身相对简单，但重建他们的代码需要很小心的实行优化。第九章会用很大篇幅讲述不同接口与交互的使用，比如视频直播需要某种特定的总线与内存接口。除此之外还需要一些数组和循环的优化。第十章介绍了几种排序算法，所以自然需要很大量的优化。最后一章则是建立了一个复杂的数据压缩结构，会包含大量复杂的模块。 Copyright © xupsh.github.io 2018 all right reserved，powered by Gitbook 该文件修订时间： 2018-06-18 15:09:08 "},"02-Finite-Impulse-Response-Filters.html":{"url":"02-Finite-Impulse-Response-Filters.html","title":"第二章","keywords":"","body":"第二章 Copyright © xupsh.github.io 2018 all right reserved，powered by Gitbook 该文件修订时间： 2018-06-18 15:09:08 "},"03-CORDIC.html":{"url":"03-CORDIC.html","title":"第三章","keywords":"","body":"第三章 Copyright © xupsh.github.io 2018 all right reserved，powered by Gitbook 该文件修订时间： 2018-06-18 15:09:08 "},"04-Discrete-Fourier-Transform.html":{"url":"04-Discrete-Fourier-Transform.html","title":"第四章","keywords":"","body":"第四章 离散傅里叶变换 本章介绍了DFT，并将重点放在了介绍了DPT在FPGA实现中的算法优化。DFT运算的核心是以一组固定系数执行矩阵向量乘法。在4.6章节中，我们首先将DFT运算初始优化集中在将其简化为矩阵 - 向量乘法，随后介绍了DFT使用Vivado HLS代码的完整实现方式。 另外，我们也描述了如何最佳地优化DFT计算以增加吞吐量。第4.5章中，我们将的优化工作集中在阵列分区优化上。 本章的前两小节有大量的数据计算和推导，这可能看起来有些多余，但是它对于我们充分理解代码重构优化以下一章快速傅里叶变换的对称性计算有着很大作用。但是如果你对HLS 优化内容更感兴趣，可以直接跳至第4.6章开始阅读。 4.1 傅里叶级数 为了解释离散傅里叶变换，我们首先要了解傅里叶级数。傅立叶级数提供了一种可选方法来观察信号从-π到π的一个周期内的连续实值周期信号。Jean Baptiste Joseph Fourier的开创性成果表明，在2π周期内任何连续的周期性信号都可以用周期为2π的余弦和正弦和表示。最终，傅里叶级数的表现形式如下： f(t)∼a02+a1cos(t)+a2cos(2t)+a3cos(3t)+⋯b1sin(t)+b2sin(2t)+b3sin(3t)+⋯∼a02+∑n=1∞(ancos(nt)+bnsin(nt)(4.1) \\begin{aligned} f(t)\\sim\\frac{a_{0}}{2}+a_{1}cos(t)+a_{2}cos(2t)+a_{3}cos(3t)+\\cdots \\\\ b_{1}sin(t)+b_{2}sin(2t)+b_{3}sin(3t)+\\cdots \\\\ \\sim\\frac{a_{0}}{2}+{\\sum_{n=1}^{\\infty}}(a_{n}cos(nt)+b_{n}sin(nt) \\end{aligned} \\quad(4.1) f(t)∼2a0​​+a1​cos(t)+a2​cos(2t)+a3​cos(3t)+⋯b1​sin(t)+b2​sin(2t)+b3​sin(3t)+⋯∼2a0​​+n=1∑∞​(an​cos(nt)+bn​sin(nt)​(4.1) 其中参数a0,a1,⋯a_{0},a_{1},\\cdotsa0​,a1​,⋯和b0,b1,⋯b_{0},b_{1},\\cdotsb0​,b1​,⋯的计算公式如下： a0=1π∫−ππf(t)dta_{0}=\\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}f(t)dta0​=π1​∫−ππ​f(t)dt an=1π∫−ππf(t)cos(nt)dt(4.2)a_{n}=\\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}f(t)cos(nt)dt\\quad\\quad(4.2)an​=π1​∫−ππ​f(t)cos(nt)dt(4.2) bn=1π∫−ππf(t)sin(nt)dtb_{n}=\\frac{1}{\\pi}\\int_{-\\pi}^{\\pi}f(t)sin(nt)dtbn​=π1​∫−ππ​f(t)sin(nt)dt 有几个需要注意的点是：首先式4.2中的参数a0,a1,⋯a_{0},a_{1},\\cdotsa0​,a1​,⋯,b0,b1,⋯b_{0},b_{1},\\cdotsb0​,b1​,⋯被称作傅里叶参数。其中参数 a0a_{0}a0​ 被称作直流分量（来自于对早期电流分析的参考），其中n=1频率分量称为基波，而其他频率（n≥2）分量统称为高次谐波。基波和高次谐波的概念来自声学和音乐。其次，函数f以及cos()和sin()函数都有2π个周期; 我们很快就会展现如何将这个周期改变为其他值。 直流分量a0a_{0}a0​等同于cos(0·t)=1时的系数，因此使用符号a。因为sin(0·t)=0，所以不需要 b0b_{0}b0​ 的值。最后，在某些情况下，函数f和它的傅里叶级数之间是近似相等的关系，这种不连续的现象我们称之为吉布斯现象。而这是只是一个仅与傅里叶级数有关的小问题，与其他傅立叶变换无关。 因此，今后我们将忽略式[4.1]中的“近似”（〜），直接视为“相等”（=）。 表示除π以外的周期性函数需要对变量进行简单的更改。 假设一个函数的周期范围在[-L,L]而不是[-π,π],则设： t≡πt′L(4.3)t\\equiv\\frac{\\pi t^{'}}{L}\\quad(4.3)t≡Lπt′​(4.3) 以及 dt≡πdt′L(4.4)dt\\equiv\\frac{\\pi{d} t^{'}}{L}\\quad(4.4)dt≡Lπdt′​(4.4) 这是一个简单地将周期区间从[-π,π]变换到期望的[-L,L]的一个线性方程，将t′=Ltπt^{'}=\\frac{Lt}{\\pi}t′=πLt​ 代入到式4.1得： f(t′)=a02+∑n=1∞(ancos(nπt′L)+bnsin(nπt′L))(4.5) f(t^{'})=\\frac{a_{0}}{2}+{\\sum_{n=1}^{\\infty}}(a_{n}cos(\\frac{n\\pi{t^{'}}}{L})+b_{n}sin(\\frac{n\\pi{t^{'}}}{L}))\\quad(4.5) f(t′)=2a0​​+n=1∑∞​(an​cos(Lnπt′​)+bn​sin(Lnπt′​))(4.5) 用同样的方法解得a和b的各项参数可解得： a0=1L∫−LLf(t′)dt′a_{0}=\\frac{1}{L}\\int_{-L}^{L}f(t^{'})dt^{'}\\quada0​=L1​∫−LL​f(t′)dt′ an=1L∫−LLf(t′)cos(nπt′L)dt′(4.6)a_{n}=\\frac{1}{L}\\int_{-L}^{L}f(t^{'})cos(\\frac{n\\pi{t^{'}}}{L})dt^{'}\\quad(4.6)an​=L1​∫−LL​f(t′)cos(Lnπt′​)dt′(4.6) bn=1L∫−LLf(t′)sin(nπt′L)dt′b_{n}=\\frac{1}{L}\\int_{-L}^{L}f(t^{'})sin(\\frac{n\\pi{t^{'}}}{L})dt^{'}\\quad\\quadbn​=L1​∫−LL​f(t′)sin(Lnπt′​)dt′ 我们也可以利用欧拉公式 ejnt=cos(nt)+jsin(nt)e^{jnt}=cos(nt)+jsin(nt)ejnt=cos(nt)+jsin(nt) 来得出一个更简洁的公式。 f(t)=∑n=−∞∞cnejnt(4.7)f(t)=\\sum_{n={-\\infty}}^{\\infty}c_{n}e^{jnt}\\quad(4.7)f(t)=n=−∞∑∞​cn​ejnt(4.7) 其中，傅里叶参数cnc_{n}cn​ 是一个较为复杂的指数表达式： cn=12π∫−ππf(t)e−jntdt(4.8)c_{n}=\\frac{1}{2\\pi}\\int^{\\pi}_{-\\pi}f\\left(t\\right)e^{-jnt}dt\\quad(4.8)cn​=2π1​∫−ππ​f(t)e−jntdt(4.8) 假设f(t)是一个具有2π个周期的周期函数，将这个公式与式4.1等效，傅里叶参数an,bn,andcna_{n},b_{n}, and\\,c_{n}an​,bn​,andcn​ 之间的数值关系为: an=cn+c−nforn=0,1,2,⋯a_{n}=c_{n}+c_{-n}forn=0,1,2,\\cdots\\quad\\quadan​=cn​+c−n​forn=0,1,2,⋯ bn=j(cn−c−n)forn=0,1,2,⋯b_{n}=j(c_{n}-c_{-n})forn=0,1,2,\\cdots\\quad\\quadbn​=j(cn​−c−n​)forn=0,1,2,⋯ Cn={12(an−jbn)n>012a012(a−n+jb−n)n0(4.9) C_{n}=\\begin{cases}\\frac {1}{2}\\left( a_{n}-jb_{n}\\right) n >0\\\\ \\frac {1}{2}a_{0}\\\\ \\frac {1}{2}\\left( a_{-n}+jb_{-n}\\right) n Cn​=⎩⎪⎨⎪⎧​21​(an​−jbn​)n>021​a0​21​(a−n​+jb−n​)n0​(4.9) 我们需要注意的是参数an,bn,cna_{n},b_{n},c_{n}an​,bn​,cn​ 的公式中引入了“负”频率的概念。虽然从物理的角度上看它没有实际意义，但在数学上我们可以将其视为复平面上的“负”旋转。正频率表示复数在复平面上以逆时针方向旋转，负频率表示我们在复平面上以顺时针方向旋转。 余弦，正弦和复指数之间的关系更加证明了上面这个理论，余弦既可以看作复指数的实数部分，也可以推导为一个正频率和一个负频率两个复指数的和，如式4.10所示。 cos(x)=Re(ejx)=eix+e−jx2cos(x)=Re\\left(e^{jx}\\right) =\\dfrac{e^{ix}+e^{-jx}}{2}cos(x)=Re(ejx)=2eix+e−jx​ 正弦和复指数之间的关系如式4.11所示，与余弦的不同点在于这里我们减去负频率并除以2j。 sin(x)=Im(ejx)=eix−e−jx2jsin(x)=Im\\left(e^{jx}\\right) =\\dfrac{e^{ix}-e^{-jx}}{2j}sin(x)=Im(ejx)=2jeix−e−jx​ 这两种正余弦和复指数之间的关系都可以用复平面矢量图的形式来理解，如下图4.1所示。图4.1中a)部分显示了余弦的推导过程，这里我们添加两个复平面向量ejxe^{jx}ejx and e−jxe^{-jx}e−jx，图中可以看出这两个向量和是一个在实轴上的向量，大小为2cos(x)。所以，当我们将这两个向量的和除以2就到了式4.10中的cos(x)的值。图4.1中b)部分显示了类似的正弦的推导过程，这里我们添加两个复平面向量ejxe^{jx}ejx and e−jxe^{-jx}e−jx，图中可以看出这两个向量差是一个在虚轴上的向量，大小为2sin(x)。所以，当我们将这两个向量的差除以2j就到了式4.11中的sin(x)的值。 4.2 DFT背景介绍 上一节我们探究了傅里叶级数的分析数学基础，证明了它对于周期连续性信号的作用，而离散傅里叶变换是针对于离散的周期信号的。DFT可以将有限数量的等间隔样本转换为有限数量的复数正弦曲线。换句话说，它将一个采样函数从一个域（通常是时域）转换到频域。复数正弦曲线的频率取为与输入函数的采样周期相关的频率的基频的整数倍。离散信号和周期信号最重要的关联在于它可以用一组有限的数字表示。因此，可以使用数字系统来实现DFT。 ejxe^{jx}ejx and e−jxe^{-jx}e−jx 的和。 这个求和的结果恰好落在实值轴上，其值为2cos(x)。b）部分显示了一个类似的总和，只是这次对矢量ejxe^{jx}ejx and −e−jx-e^{-jx}−e−jx 求和。 这个总和落在虚轴上，其值为2sin(x).\"> DFT适用于同时包含实数和复数的输入函数。直观上，为了轻松入门，我们暂时忽略复数部分，从实数信号开始了解实际DFT的工作原理。 关于术语的简要说明：我们使用小写函数变量来表示时域中的信号，大写函数变量来表示频域中的信号。我们使用（）表示连续函数，用[ ]表示离散函数。例如，f（）是连续的时域函数，F（）是其连续的频域表示。类似地，g[]是时域中的离散函数，G[]是将该函数转换到频域。 让我们从图4.2开始分析，左图是一个具有N个样本或从0到N-1运行的点的实值时域信号g[]。当我们用DFT分析时域信号时，会得出对应于各个频率的余弦和正弦幅度的频域信号。这些可以看作是余弦幅值对应复数的实数值，而正弦幅值对应复数的虚数的复数，其中包含有有N/2+1个余弦（实数）和N/2+1个正弦（虚数）值。我们称之为复频域函数G []。注意，频域中样本的数量为（N/2+1）是由于我们正在分析一个只包含实数的时域信号，复数时域信号经过DFT后将变为具有N个样本的频域信号。 一个具有N个样本点的DFT可以通过一个N×N矩阵乘以一个大小为N的矢量来确定。G = S·g其中 [111…11ss2…sN−11s2s4…s2(N−1)1s3s6…s3(N−1)⋮⋮⋮⋱⋮1sN−1s2N−1…s(N−1)(N−1)](4.12) \\begin{bmatrix} 1 & 1 & 1 &\\ldots &1\\\\ 1 & s &s^{2} &\\ldots &s^{N-1}\\\\ 1 & s^{2} &s^{4} &\\ldots &s^{2(N-1)}\\\\ 1 & s^{3} &s^{6} &\\ldots &s^{3(N-1)}\\\\ \\vdots& \\vdots &\\vdots &\\ddots &\\vdots\\\\ 1 & s^{N-1} &s^2{N-1} &\\ldots &s^{(N-1)(N-1)} \\end{bmatrix}\\quad(4.12) ⎣⎢⎢⎢⎢⎢⎢⎡​1111⋮1​1ss2s3⋮sN−1​1s2s4s6⋮s2N−1​…………⋱…​1sN−1s2(N−1)s3(N−1)⋮s(N−1)(N−1)​⎦⎥⎥⎥⎥⎥⎥⎤​(4.12) 和s=e−i2πNs=e^{\\frac{-i2\\pi}{N}}s=eN−i2π​。 因此，频域中的样本被推导为 G[t]=∑n=0N−1g[n]sknfork=0,…,N−1(4.13)G[t]=\\sum_{n={0}}^{N-1}g[n]s^{kn}\\quad for \\; k=0,\\ldots,N-1\\quad(4.13)G[t]=n=0∑N−1​g[n]sknfork=0,…,N−1(4.13) 图4.3提供了8个样本点的DFT操作的系数的可视化分析图。八点频域采样是通过将8个时域采样与S矩阵的对应行相乘而得到的。S矩阵的行0对应于与时域采样的平均值成比例的DC分量。将S矩阵的第1行与g相乘，得出围绕单位圆圈旋转一圈时的余弦和正弦振幅值。由于这是一个8点DFT，这意味着每个相位偏移45°。执行8个45°旋转将围绕单位圆完整旋转一圈。第2行是相似的，唯一不同点是围绕单位圆执行两次旋转，即每次旋转90°。这是一个更高的频率。第3排做三次旋转; 第4排四轮旋转等等。每一个这样的行时间列乘法中都给出了适当的频域样本。 我们可以注意到S矩阵是对角对称矩阵，即S[i][j]=S[j][i]S[i][j]=S[j][i]S[i][j]=S[j][i]。另外，S[i][j]=sisj=si+jS[i][j]=s^{i}s^{j}=s^{i+j}S[i][j]=sisj=si+j。在第四行周围也会出现有趣的对称性现象。行3和行5中的相量是彼此的共轭复数，即S[3][j]=S[5][j]∗S[3][j]=S[5][j]^{\\ast}S[3][j]=S[5][j]∗。 类似地，行2和6 (S[2][j]=S[6][j]∗)(S[2][j]=S[6][j]^{\\ast})(S[2][j]=S[6][j]∗) 以及行1和7 (S[1][j]=S[7][j]∗)(S[1][j]=S[7][j]^{\\ast})(S[1][j]=S[7][j]∗) 都是彼此的共轭复数。 正是由于这个原因，具有N个采样点的实值输入信号的DFT在频域中仅具有N/2+1个余弦和正弦值。剩余的N/2个频域值提供了冗余信息，因此不需要它们。然而，当输入信号复杂时，情况并非如此。在这种情况下，频域将有N+1个余弦和正弦值。 #define SIZE 8 typedef int BaseType; void matrix_vector(BaseType M[SIZE][SIZE], BaseType V_In[SIZE], BaseType V_Out[SIZE]) { BaseType i, j; data_loop: for (i = 0; i 图4.4 实现矩阵向量乘法的简单代码 4.3 矩阵向量乘法的优化 矩阵向量乘法是DFT计算的核心，输入的时域向量将乘以一个固定特殊值的矩阵，输出的结果是与输入时域信号表示相对应的频域矢量。 在本节中，我们讨论如何在硬件中实现矩阵向量乘法。我们把这个问题分解成最基本的形式（见图4.4）。这让我们能够更好地将讨论集中在算法优化上，而不是集中在使用功能正确的DFT代码的所有难点上。在下一节中我们将构建一个DFT内核。 图4.4中的代码提供了将该算法实现到硬件中的原始形式，代码中使用当前被映射为浮点型的BaseType的自定义数据类型。虽然这在刚开始看起来可能是多余的，但是可以方便我们在将来轻松地将变量（例如，具有不同精度的有符号或无符号的定点）进行不同的数字表示。 matrix_vector 功能共有三个参数，我们对前两个参数进行乘法计算，输入矩阵和向量分别是 BaseType M[SIZE][SIZE] 和 BaseType V In[SIZE]。第三个参数 BaseType V_Out[SIZE] 是合成向量。我们将M=S和V_in设为采样时域信号，则Vout将包含DFT。SIZE是决定输入信号中样本数量的常数，相应地也决定了DFT的大小。 这个算法本身只是一个嵌套的for循环。内部循环（ dot_product_loop）从0至SIZE-1计算DFT的系数。但是，这个相对简单的代码在映射到硬件执行时，就有许多种设计方案可选择。 无论何时执行HLS，你都应该考虑希望合成怎样的结构体系。内存结构的组织在这个过程中显得尤为重要。这个问题可以归结为你将代码中的数据存储到哪里？因为将变量映射到硬件时有许多选项。该变量可能只是一组信号（如果它的值永远不需要在一个周期内保存）、寄存器、RAM或FIFO。但所有这些选项都需要你在速度和面积之间作出折衷的选择。 另一个我们需要考虑的重要因素是代码并行度的可用性。纯粹的顺序代码到硬件上实现相当困难。换句话说，一个具有足够并行可行性的代码，从纯粹顺序执行到完全并行实现有一个可以选择的实现自由度。这样的选择显然会带来不同的面积和速度。我们将研究内存配置和并行性如何影响DFT矩阵向量的硬件实现。 图4.5显示了包含一个乘法和一个加法运算符的矩阵向量乘法的顺序结构。我们创建逻辑以访问存储在BRAM中的V_In和矩阵M。计算V_Out的每个元素并存储到BRAM中。这种体系结构本质上是将图4.4中的代码合成为无指令的结果。它不占用大量面积，但任务延迟和任务间隔相对较大。 4.4 流水线和并行运行 在矩阵乘法的例子中，我们可以很大程度地利用并行思想来解决问题。首先关注每次迭代循环执行的内部循环表达式 sum+=Vin[j]∗M[i][j]sum+= V_in [j] * M [i] [j]sum+=Vi​n[j]∗M[i][j]。乘法运行时，计数变量SUM在每次迭代中都被重复利用并赋予新的值。如图4.6所示，这个内部循环可以重新表述，此时变量 SUM 已被完全消除，并在较大表达式中替换为多个中间值。 #define SIZE 8 typedef int BaseType; void matrix_vector(BaseType M[SIZE][SIZE], BaseType V_In[SIZE], BaseType V_Out[SIZE]) { BaseType i, j; data_loop: for (i = 0; i 图4.6: 手动展开矩阵向量乘法内部循环实例 循环的展开可以由Vivado HLS在流水线上下文中自动执行,也可以通过使用#pragma HLS展开或者流水线上下文外的等价指令来实现。 我们应该已经发现替换内部循环的新表达式应具有大量的并行性。如此而来每个乘法可以同时执行，并且可以使用加法器树来执行求和。这个计算的数据流图如图4.7所示。 如果我们希望展开内循环的表达式的任务延迟最小，那么所有的八个乘法运算都应该并行执行。假设乘法有3个周期的延迟且加法有1个周期的延迟，则所有V_In[j]∗M[i][j]V\\_In[j] * M [i][j]V_In[j]∗M[i][j] 操作在第三周期结束时完成。使用加法器树对这八个中间结果进行求和需要log8=3log8 = 3log8=3个周期。因此，对于每次迭代，数据循环主题将共有6个周期的延迟，并且需要8个乘法器和7个加法器，如图4.8左侧所示。需要注意的是，如果在循环4-6中重复使用加法器，这会将加法器的数量减少到4个。但是，在FPGA上加法器通常是无法共享的，因为加法器和多路复用器需要相同数量的FPGA资源（对于2输入运算，大约1个LUT每比特）。 如果我们不愿意使用8个乘法器，则可以增加执行该功能的周期数量来减少资源使用量。例如，使用4个乘法器会使得8个V_In[j]∗M[i][j]V\\_In [j] * M [i] [j]V_In[j]∗M[i][j] 乘法操作带来6个周期的延迟，那么完成整个数据循环体将会有9个周期的总延迟，如图4.8的右侧所示。为了使用更少的乘法器，我们需要牺牲更多的时间周期来完成内部循环。 从图4.8中我们可以明显看出有很多重要的时间段并没有执行有效的工作，因而降低了设计的总体效率。我们应该尽量缩短这些时间来提高效率。在这种情况下，可以发现data_loop的每次迭代实际上是完全独立的，这意味着它们可以同时执行。正如我们展开dot_product_loop一样，也可以展开数据循环并同时执行所有的乘法运算。但是，这需要大量的FPGA资源。我们还有更好的选择是尽快地启动循环的每次迭代，意味着前一次循环仍在执行。这个过程被称为循环流水线化，我们通过#pragma HLS pipeline在Vivado HLS中实现。 在大多数情况下，循环流水线会减少循环的间隔时间，但不会影响延迟时间。循环流水线的实现如图4.9所示。 截至目前，我们的关注点集中在操作运行的延迟上。功能单元通常也是流水线式的，Vivado HLS中的大多数功能单元都是间隔为1的流水线式的。尽管单次乘法操作可能需要3个周期才能完成，但新的乘法操作可以从流水线乘法器的每个时钟周期开始。通过这种方式，单个功能单元可以同时执行多个乘法操作。例如，有3个周期延迟且间隔为1的乘数可以同时执行三次乘法运算。 充分利用流水线乘法器的优势就在于我们就可以在不添加额外运算符的前提下减少内部循环的延迟。图4.10中左边展示了使用三个流水线乘法器一种可能的实现方式。在这种情况下，乘法操作可以并发执行（因为它们没有数据依赖性），而加法操作只有在第一次乘法完成之后才能开始。在右图中，显示了该设计间隔为3的流水线版本，如果将#pragma HLS pipeline II=3应用于data_loop，则与Vivado R HLS的结果类似。这样不仅个别操作在同一个操作符上并发执行，而且这些操作可能来自于不同data_loop的迭代。 现在你可能已经观察到，我们可以在不同的层次级别上进行流水线操作，包括算法级别，循环级别和功能级别。此外，不同级别的流水线在很大程度上也是独立的！我们可以在顺序循环中使用流水线操作符，或者我们可以使用顺序操作符来构建流水线循环，也可以构建大型功能的流水线实现。这些功能可以像原始运算单元一样在Vivado HLS 中共享。我们实例化了多少运算单元，它们的个体成本以及使用频率如何才是最重要的。 4.5 存储权衡和数据分区 到了本小节，我们已经假定数组中的数据 V_In[],M[][]和V_Out[]可以随时访问，但是实际上，数据的放置的位置对整个处理器的性能和资源使用情况有重要影响。在大多数处理器系统中，内存架构是固定的，我们只能调整程序以尝试最大程度地利用可用的内存层次结构，例如注意尽可能减少寄存器溢出和缓存丢失。在HLS设计中，我们还可以利用不同的存储器结构，并尝试找到最适合特定算法的存储器结构。通常，大量数据存储在片外存储器如DRAM、闪存或网络连接的存储器中，但是数据访问时间通常很长，大约为几十到几百（或更多）个周期。由于大量的电流必须流过长电线已访问片外存储器，所以使用片外存储消耗的能量也比较大。相反，片上存储器可以快速访问并且功耗要低得多，只是它可以存储的数据量有限。有一种常见的操作模式类似于通用CPU的内存层次结构中的缓存效果，它是将数据重复地加载到块中的片上存储器上。 当我们选择片上存储器的时候，需要在嵌入式存储器（例如Block RAM）或触发器（FF）之间权衡。基于触发器的存储器允许在一个时钟内对不同地址的数据进行多次读取，也可以在一个时钟周期内读取、修改和写入基于触发器的存储器。然而，即使在资源配置最好的设备中，FF的数量通常也限制在大约10万字节左右。实际上，以便有效地使用其他FPGA资源，大多数基于FF的存储器应该小得多。Block RAM（BRAM）提供更高的容量，拥有Mbytes的存储量，其代价是有限的可访问性。例如，单个BRAM可以存储大于1到4千字节的数据，但是在每个时钟周期只可以对该数据的两个不同的地址进行访问。此外，BRAM需要尽可能减少流水线操作（比如，读操作必须具有至少一个周期的延迟）。因此，我们的基本的权衡点在于工程所需的带宽与容量。 如果说数据的吞吐量我们需要考虑的头号问题，则所有数据都将存储在FF中。这将允许任何元素在每个时钟周期内被访问尽可能多的次数。但是，随着矩阵阵列变大，这种方案也将变得不可行。在矩阵向量乘法的情况下，存储1024位乘以1024位矩阵的32位整数将需要大约4兆字节的存储器。即使使用BRAM来存储，由于每个BRAM存储大约4KBytes，也需要大约1024个BRAM块。另一方面，使用单个大型基于BRAM的内存意味着我们一次只能访问两个元素。这明显降低了性能，如图4.7所示，它需要在每个时钟周期访问多个数组元素（V_In[]的所有8个元素以及M[][]的8个元素）。在实际工程中，大多数设计需要更大的阵列分布存放在更小的BRAM存储器中，这种方法称为阵列分区。较小的数组（通常用于索引较大的数组）可以完全划分为单独的标准变量并映射到FF。匹配流水线选择和数组分区以最大限度地提高运算符使用率和内存使用率是HLS设计探索的一个重要方面。 Vivado HLS 将自动执行一些阵列分区，但由于阵列分区倾向于某些特定设计，因此通常需要我们利用好工具以获得最佳结果。阵列分区的全局配置可在config_array_partiton选项中找到。单个数组可以使用array_patition指令来显示分区，并将指令数组分区完成将数组的每个元素分解到它自己的寄存器中，最终形成基于FF内存。与许多其他基于指令的优化一样，通过手动重写代码也可以实现相同的效果。一般情况下，最好使用工具指令，因为它避免了引入错误并易于代码维护。 回到图4.4中的矩阵向量乘法代码，我们可以通过添加几个指令来实现高度并行，如图4.11所示，最终的体系结构如图4.12所示。请注意，内部j循环由Vivado HLS 自动展开，因此j在每次使用的时候都被替换为常量。此设计演示了阵列分区的最常见用法，其中分区的数组维度（在本例中为V_In[]和第二维的M[][]）都被索引为常量（在本例中为循环索引j来展开循环）。这使得多路复用器可以无需访问分区阵列架构。 我们还可以用更少的乘法器降低性能以实现其他设计。例如，在图4.10中，这些设计只使用三个乘法器，因此我们只需要在每个时钟周期读取三个矩阵M[][]和矢量V_in[]的元素。完全分割这些数组会导致额外的多路复用，如图4.13所示。实际上，阵列只需要分成三个物理存储器。同样，这种分区可以通过重写代码手动实现，也可以使用array_patition循环指令在Vivado HLS中实现。 让我们从包含数据的矩阵X来分析： #define SIZE 8 typedef int BaseType; void matrix_vector(BaseType M[SIZE][SIZE], BaseType V_In[SIZE], BaseType V_Out[SIZE]) { #pragma HLS array_partition variable=M dim=2 complete #pragma HLS array_partition variable=V_In complete BaseType i, j; data_loop: for (i = 0; i 图4.11 选用阵列分割和流水线操作的矩阵向量乘法 相似地，如果我们使用 array_patition variable=x factor=2 block 指令可以将它分为两个矩阵向量： 让我们来研究一下变化的流水线II和阵列分区对性能和面积的影响，比较根据每秒的矩阵向量乘法运算（吞吐量）和根据展开阵列分区因子的数量的性能高低，并绘制相同的区域趋势图（如显示LUT，FF，DSP模块，BRAM）。再思考这两种情况的总趋势是什么？你会选择哪种设计？为什么？ 通过流水线操作并将部分循环展开应用于 dot_product_loop，我们也可以得到类似的结果。图4.14显示了将矩阵向量乘法代码的内部循环展开2倍的结果。你可以发现，循环的边界现在增加到2；每个循环迭代需要2个矩阵M[][]和向量Vin[]每次迭代并执行两次乘法而不是一次。使用这种方式循环展开后，对应于原始循环的两次迭代，Vivado HLS可以并行地在两个表达式中实现这些操作。请注意，如果没有适当的数组分区，展开内部循环可能不会提高性能，因为并发读取操作的数量受到内存端口数量的限制。在这种情况下，我们可以将来自偶数列的数据存储在一个BRAM中，将来自奇数列的数据存储在另一个BRAM中。这是因为展开的循环总是执行一次偶数迭代和一次奇数迭代。 #define SIZE 8 typedef int BaseType; void matrix_vector(BaseType M[SIZE][SIZE], BaseType V_In[SIZE], BaseType V_Out[SIZE]) { #pragma HLS array_partition variable=M dim=2 cyclic factor=2 #pragma HLS array_partition variable=V_In cyclic factor=2 BaseType i, j; data_loop: for (i = 0; i 图4.14 内部循环展开2倍的矩阵向量乘法代码。 HLS工具可以使用 unroll 指令自动展开循环。该指令采用一个因子作为参数，它是一个正整数，表示循环体应该展开的次数。 使用 array_partition cyclic factor = 2 指令和将 M[][]和向量 V_in[]手动划分为单独的数组有着相同的效果。考虑一下应该如何修改代码才能更改访问模式呢？ 现在我们手动将循环展开为两倍。原始代码（没有数组分区和不展开），只执行数组分区的代码，同时执行数组分区和循环展开代码之间的性能结果有哪些不同呢？ 最后，使用指令执行数组分割和循环展开的结果与手动执行的结果相比有哪些不同呢？ 在这段代码中，我们看到数组分区通常与流水线操作并行执行。通过2倍的数组分割可以使性能提高2倍，我们可以用将内环部分展开2倍或将外环的II减少2倍来实现。提升性能需要相应数量的阵列分区。在矩阵向量乘法中，这种关系相对简单，因为对内部循环中的每个变量只有一次访问权限。在其他代码中，关系可能更复杂。无论如何，设计者的目标应该是确保例化的FPGA资源得到有效利用。一般情况下，将性能提高2倍将使用大约两倍的资源，相反将性能降低2倍可以节约一半的资源。 让我们来研究一下循环展开和阵列分区对性能和面积的影响，比较根据每秒的矩阵向量乘法运算（吞吐量）和根据展开阵列分区因子的数量的性能高低，并绘制相同的区域趋势图（如显示LUT，FF，DSP模块，BRAM）。再思考这两种情况的总趋势是什么？你会选择哪种设计？为什么？ 4.6 Baseline实现 上一节中我们讨论了执行DFT的核心计算——矩阵向量乘法的一些优化方法。然而将矩阵向量乘法转移到功能完备的DFT进行硬件实现，还会出现其他问题。在本节中，我们将重点转移到DFT，并讨论如何优化以使其执行起来最有效。 处理大量复杂数字的能力是这一节我们需要着重考虑的点之一。如4.2节所述，因为S矩阵的元素是复数，所以实值信号的DFT几乎总是一个复数值信号。执行复数值信号的DFT以产生复数值结果也很常见。此外，我们需要处理分数或可能的浮点数据，而不是整数。这会增加实现的成本，尤其是需要执行浮点操作的时候。另外，浮点运算符（特别是加法运算符）比整数加法具有更大的延迟。这可以使得II = 1的循环更难以实现。第二个变化是我们希望能够将我们的设计容量扩展到一个大输入矢量的大小，比如N = 1024个输入样本。然而如果我们直接使用矩阵向量乘法，那么我们必须存储整个S矩阵。由于这个矩阵是输入大小的平方，因此这么大的一个输入矢量的存储实现起来比家里困难。本章我们将讨论解决这两个复杂问题的技巧。 正如使用HLS创建硬件实现时的典型实例一样，让我们从简单代码的实现开始。这里我们有一个可以保证它具有正确的功能baseline代码。通常，这些代码都以非常连续化的方式运行;它没有高度优化，因此可能无法达到所需的性能指标。但是，这是确保设计人员理解算法功能的必要步骤，并且可以作为未来优化的起点。图4.15显示了DFT的baseline实现。这使用双重嵌套for循环。内部循环将S矩阵的一行与输入信号相乘。该代码不是将S矩阵作为输入读取，而是基于当前循环索引，在内部循环的每次迭代中计算S中的元素。我们使用cos()和sin()函数将该相量转换为具有实部和虚部的笛卡尔坐标。该代码可将相量与适当采样的输入信号相乘并累加结果。经过该内环的N次迭代之后，每个S矩阵的列元素都被计算得出一个频域样本。外循环也迭代了N次，S矩阵的每一行都被迭代一次。最终，代码计算了N次矩阵W的表达式，但是cos()和sin()函数以及复数乘加计算进行了 n2n^{2}n2 次。 此代码使用函数调用来计算cos()和sin()值。Vivado HLS能够使用其内置的数学库来实现这样的数学计算。第3章介绍了用于实现三角函数（包括CORDIC）的几种可能的算法[22]。但是，要使这些函数生成精确的结果可能代价比较高。因为输入量不是任意的，取消这些函数调用也有几种方法。我们将在稍后更详细地讨论这些权衡方法。这个代码的顺序执行代码如图4.16所示。 #include //Required for cos and sin functions typedef double IN_TYPE; // Data type for the input signal typedef double TEMP_TYPE; // Data type for the temporary variables #define N 256 // DFT Size void dft(IN_TYPE sample_real[N], IN_TYPE sample_imag[N]) { int i, j; TEMP_TYPE w; TEMP_TYPE c, s; // Temporary arrays to hold the intermediate frequency domain results TEMP_TYPE temp_real[N]; TEMP_TYPE temp_imag[N]; // Calculate each frequency domain sample iteratively for (i = 0; i 图4.15：DFT的baseline code 如果你要使用你设计的CORDIC（如从第3章开始），那么此代码需要做什么修改？ 改变CORDIC核心的准确性会使DFT硬件资源使用情况发生变化吗？ 它会如何影响性能？ 请使用HLS实现DFT的基线代码，实现后查看报告，与乘法和加法相比，实现三元函数的相对成本是多少？ 对哪些操作尝试优化更有意义？通过流水线操作内循环可以实现什么性能？ 4.7 DFT 优化 上一节的基线的DFT实现使用了相对较高的 double 数据类型。实现浮点运算尤其是双精度浮点运算通常代价很高并且需要很多流水线操作。我们可以从图4.16中看到这显着影响了循环的性能。通过流水线操作，这些高延迟操作的影响不那么重要，因为可以同时执行多个循环执行。此代码中的例外是用于累加结果的变量temp real []和temp imag []。这个累加是一种循环，并在流水线化内循环时限制了可实现的II。该运算符的依赖性如图4.17所示。 一种可能的解决方案是降低计算的精度。这种方法在实际应用时是有价值的，因为它减少了每个操作所需的资源，减少了存储值所需的内存，并且通常也减少了操作的延迟。例如，我们可以使用32位浮点型或16位半型来替代双精度型。许多信号处理系统完全避免了浮点数据类型，并使用定点数据类型3.5。对于常用的整数和定点精度，每个加法可以在一个循环中完成，从而使循环在II = 1处流水线化。 如果将所有数据类型从双精度型更改为浮点型，那么图4.15中的代码综合结果会发生什么变化？还是从一倍到一半？或到一个固定的点值？这是如何改变性能（间隔和延迟）和资源使用情况的？它是否会更改输出频率域采样值？ 用浮点累加实现II = 1的普适解决方案是用不同的顺序处理数据。看图4.17，我们看到由于j循环是内部循环，所以重复是存在的（用箭头表示）。如果内循环是i循环，那么在下一次迭代开始之前我们就不需要累加的结果。我们可以通过交换两个循环的顺序来实现这一点。这种优化方式通常被称为循环交换或流水线交织处理[40]。由于外循环i内部的额外代码，我们可能不是很容易地发现可以重新排列循环。由于S矩阵是对角对称的，因此i和j可以在w的计算中交换。 结果是我们现在可以在内部循环中实现1的II。但是我们需要为临时实值和临时图像数组设置额外的存储器，存储计算的中间值一直到再次需要这些数据。 重新排列图4.15中代码的循环，并显示您可以使用1的II来管理内部循环。 根据DFT中S矩阵的结构，我们可以应用其他优化方式来完全消除三角运算。回想一下，S矩阵的每个元素的复矢量是通过单位圆的固定旋转角度来计算的。S矩阵的行S[0][]对应于单位圆周的零旋转，行S[1][]对应于单次旋转，并且随后的行对应于单位圆周更大角度的旋转。我们可以发现，第二行S[1][]相对应的向量覆盖了来自其他行的所有向量，因为8个列向量每个绕单位圆旋转45°，一共则围绕单位圆旋转了一圈。我们可以通过研究图9.11来直观地确认这个现象。这样我们可以只存储第二行这一次旋转中的正弦和余弦值，然后索引到这个存储器中的值以计算相应行的必要值。这只需要2×N=O（N）个存储单元可以有效减少存储器的O（N）的大小。对于1024个点的DFT，存储器的存储需求将减少到1024×2个条目。假设有一个32位的固定值或浮点值，则只需要8KB大小的片上存储器。显然，与明确存储整个S矩阵相比，明显减少了存储容量。我们将矩阵S的这个一维存储表示为s′s^{'}s′ S′=S[1][.]=[1ss2…sn−1] S^{'}=S[1][.]=\\begin{bmatrix} 1 & s &s^{2} &\\ldots &s^{n-1}\\\\ \\end{bmatrix} S′=S[1][.]=[1​s​s2​…​sn−1​] 导出一维数组 为了进一步提高性能，我们可以应用一种与矩阵向量乘法非常相似的技术。之前我们发现了提高矩阵向量乘法的性能需要对M[][]数组进行分区。但是如果用s′s^{'}s′ 表示S矩阵则意味着不再有一种有效的方法来划分s′s^{'}s′ 以增加我们在每个时钟上读取的数据量。S的每一个奇数行和列都包括s′s^{'}s′ 的每个元素。因此，我们无法像对S一样对s′s^{'}s′ 的值进行分区。这样增加我们从存储s′s^{'}s′ 的内存中读取数据端口的数量的唯一方法是复制存储。幸运的是，不像与必须读取和写入的内存，复制只读的数组的存储是相对容易的。事实上，Vivado HLS将只对在初始化且从未例化的只读存储器（ROM）自动执行此优化。这种功能的一个优点是我们可以简单地将sin（）和cos（）调用移动到数组初始化中。在大多数情况下，如果此代码位于函数的开头并仅初始化阵列，则Vivado HLS能够完全优化三角函数计算并自动计算ROM的内容。 设计一个利用 为了有效地优化设计，我们必须考虑代码的每个部分。往往是最薄弱的环节决定了设计的整体性能，这意味着，如果设计有一个瓶颈，将显著影响设计的性能。当前版本的DFT可以对输入和输出数据进行就地操作，即它存储结果相同的数组作为输入数据，输入数组 sample_real 和 sample_imag 都是有效的存储器端口，也就是说，你可以把这些参数的数组存储在相同的存储位置。这样，在任意给定的周期，我们只能获取其中一个阵列的一个数据，这可能会在函数中并行的乘法和加法运算方面产生瓶颈。这就是我们为什么必须将所有的输出结果存储在一个临时数组的原因，然后将所有这些结果复制到函数结尾处的“sample”数组中。如果我们没有执行就地操作，则不需要这样做。 修改DFT函数接口，使输入和输出存储在单独的数组中。这会如何影响你的可以执行优化？它如何改变性能？ 区域结果如何？ 4.8 结语 在本章中，我们探究了离散傅里叶变换（DFT）的硬件实现和优化方法。DFT是数字信号处理的基本操作，需要采样时域的信号并将其转换到频域。在本章的开头，我们描述了DFT的数学背景。这对于理解下一章（FFT）中所做的优化很重要。本章的其余部分集中介绍了指定和优化DFT以在FPGA上进行高效的实现。 由于DFT的核心是执行矩阵向量乘法，所以我们最初花费了一些时间来描述在执行矩阵向量乘法的简化代码上的指令级优化。这些指令级优化由HLS工具完成。我们用这个机会来阐明HLS工具执行指令优化的过程，希望如上的优化过程能让你直观地了解到工具优化的结果。 本章后节，我们为DFT提供了正确的功能实现方案，讨论了一些可以改善性能的优化，具体来说就是将系数阵列划分为不同存储器以提高吞吐量。阵列的分区优化通常是构建最高性能体系结构的关键方法。 Copyright © xupsh.github.io 2018 all right reserved，powered by Gitbook 该文件修订时间： 2018-06-18 15:09:08 "},"05-Fast-Fourier-Transform.html":{"url":"05-Fast-Fourier-Transform.html","title":"第五章","keywords":"","body":"第五章 Copyright © xupsh.github.io 2018 all right reserved，powered by Gitbook 该文件修订时间： 2018-06-18 15:09:08 "},"06-Sparse-Matrix-Vector-Multiplication.html":{"url":"06-Sparse-Matrix-Vector-Multiplication.html","title":"第六章","keywords":"","body":"第六章 Copyright © xupsh.github.io 2018 all right reserved，powered by Gitbook 该文件修订时间： 2018-06-18 15:09:08 "},"07-Matrix-Multiplication.html":{"url":"07-Matrix-Multiplication.html","title":"第七章","keywords":"","body":"第七章 Copyright © xupsh.github.io 2018 all right reserved，powered by Gitbook 该文件修订时间： 2018-06-18 15:09:08 "},"08-Prefix-Sum-and-Histogram.html":{"url":"08-Prefix-Sum-and-Histogram.html","title":"第八章","keywords":"","body":"第八章 Copyright © xupsh.github.io 2018 all right reserved，powered by Gitbook 该文件修订时间： 2018-06-18 15:09:08 "},"09-Video-Systems.html":{"url":"09-Video-Systems.html","title":"第九章","keywords":"","body":"第九章 视频系统 9.1 背景 ​视频处理是目前FPGA上常见的应用。其中一个选择FPGA处理视频应用的原因是目前的FPGA时钟处理频率可以很好地满足常见视频数据对处理速率的要求。例如，一般的高清视频格式，全高清视频格式（1080p@60HZ）需要的处理速率是1920（像素/行）x 1080（行/帧）x 60（帧/秒） = 124,416,000（像素/秒）。 ​当对数字视频流（1080p@60HZ）进行编码时(1080p视频帧实际传输时像素大小为2200x1125，其中行2200像素 = 行同步+行消隐前肩+有效像素（1920像素）+行消隐后肩，场1125 行=场同步+场消隐前肩+有效行（1080行）+ 场消隐后肩 ），其中消隐像素也会伴随有效像素以148.5MHz（1080P@60HZ）的频率在FPGA流水线电路中进行处理。为了达到更高的处理速率可以通过在每个时钟周期内处理多个采样数据的方式实现。数字视频是如何传输的详细内容介绍将在9.1.2小节中展开。另一个选择FPGA处理视频应用需求的原因主要是因为视频按扫描线顺序从左上角像素到右下角像素的顺序进行处理，如图9.1所示。这种可预测的视频数据处理顺序允许FPGA在无需消耗大量存储器件的条件下构建高效的数据存储架构，从而有效地处理视频数据。这些体系结构的详细信息将在第9.2.1小节中介绍。 ​视频处理应用是HLS一个非常好的目标应用领域。首先，视频处理通常是可以容忍处理延迟的。尽管一些应用可能会将整体延迟限制到一帧之内，但是许多视频处理应用中是可以容忍若干帧的处理延迟。因此，在HLS中使用接口和时钟约束方式实现的高效的流水线处理，可以不用考虑处理时延问题。其次，视频算法往往非常不统一，算法一般是基于算法专家的个人喜好或擅长的方式被开发的。一般情况下它们是被使用可以快速实现和仿真的高级语言开发的。虽然全高清视频处理算法在FPGA处理系统上可以以每秒60帧处理速度运行或者是在笔记本电脑上通过使用综合的C/C++代码以每秒一帧的处理速度运行是很常见的，但是RTL级仿真时仅能一个小时一帧的速度运行。最后，视频处理算法通常以适合HLS容易实现的嵌套循环编程风格编写。这意味着来自算法开发人员编写的许多视频算法的C / C ++原型代码均可以被综合成相应的FPGA电路。 9.1.1 视频像素表示 ​许多视频输入和输出系统都是围绕人类视觉系统感知光线的方式进行优化的。第一个原因就是眼球中的视锥细胞对红、绿和蓝光敏感。其他颜色都可以视为红、绿和蓝色的融合。因此，摄像机和显示器模仿人类视觉系统的功能，对红、绿、蓝光采集或者显示红、绿和蓝像素，并用红色、绿色和蓝色分量的组合来表示颜色空间。最常见的情况是每个像素使用24位数据位表示，其中红绿蓝每个分量各占8位数据位，其中颜色分量的数据位的位数也存在其他情况，例如高端系统中的每个像素颜色分量可以占10位位深或甚至12位位深。 ​第二原因是人类视觉系统对亮度比对颜色更敏感。因此，在一个视频处理系统内，通常会将RGB颜色空间转换到到YUV颜色空间，它将像素描述为亮度（Y）和色度（U和V）的分量组合，其中色度分量 U和V是独立于亮度分量Y的。例如常见视频格式YUV422，就是对于4个像素点，采样4个Y的值，两个U的值，两个V的值。这种格式应用于视频压缩时的采样叫色度子采样。另一种常见的视频格式YUV420表示采样4个像素值由4个Y值，一个U值和一个V值组成，进一步减少了表示图像所需像素数据。视频压缩通常在YUV色彩空间中进行。 ​第三个方面是由于眼睛中的眼杆和感光部分对绿光比对红光更加敏感，并且大脑主要从绿光中获取亮度信息。因此，图像传感器和显示器采用马赛克模式，比如采样2个绿色像素和1个红像素与1个蓝像素比例的Bayer模式。于是在相同数量焦平面采集单元或显示器显示单元条件下系统可以采集或显示更高分辨率的图像，从而降低图像采集传感器或显示器的制造成本。 视频系统多年来一直围绕人类视觉系统进行设计。最早的黑白相机对蓝绿光敏感，以匹配眼睛对该颜色范围内亮度的敏感度。然而，不幸的是它们对红光不太敏感，因此红色（如红妆）在相机上看起来不正常。当时针对这个问题的解决方案绝对是低技术含量的：拍照时演员穿着华丽的绿色和蓝色化的妆。 9.1.2 数字视频格式 ​除了表示个别的像素之外，数字视频格式必须以视频帧的形式对像素进行组织和编码。在很多情况下，通过同步或同步信号的方式来表示连续像素序列的视频帧开始和结束。在某些视频接口标准（如数字视频接口或DVI）中，同步信号使用单独的物理线路引出。在其他标准（如数字电视标准BTIR 601/656）中，同步信号的开始和结束由不会出现在视频信号中的特殊像素值表示。 ​相邻行像素之间（从左到右顺序扫描）由水平同步信号分隔开，且相邻行像素之间的水平同步信号由若干时钟周期的脉冲信号组成。另外，在水平同步信号和有效像素信号中间还有若干时钟周期的无效信号，这些信号称为行前肩和行后肩。同样，相邻帧信号之间（从上到下顺序扫描）由垂直同步脉冲分隔。每个视频帧之间有若干行有效的帧同步信号。注意，相邻帧之间的垂直同步信号仅在视频帧的开始出现。同样，帧视频信号中除了同步信号和视频有效信号外，还有无效视频行组成的场前肩和场后肩信号。另外，大多数数字视频格式包含表示有效视频像素起始的数据使能信号。因此，所有无效的视频像素一起组成水平消隐间隔和垂直消隐间隔。这些信号如图9.2所示。 数字视频信号均是对原来电视标准的模拟信号（美国的NTSC和许多欧洲国家的PAL）通过抽样、量化和编码后形成。由于用于模拟阴极射线管扫描的硬件具有有限的电平转换速率，所以水平和垂直同步间隔的时间要满足从硬件恢复扫描到下一行的开始。同步信号由若干个时钟周期的低电平组成。另外，由于电视无法有效地显示靠近同步信号的像素，因此引入前肩信号和后肩信号，这样就可以显示更多的图片像素。即使如此，由于许多电视机都是基于电子束扫描原理设计的，所以其中的图像数据有20％的边框处的像素是不可见。 ​如图9.2所示，典型1080P（60Hz）视频帧共包含2200 1125个数据采样像素点。在每秒60帧的情况下，这相当于每秒总共148.5百万的采样像素点。这比1080P（60Hz）帧中的有效视频像素的平均速率（1920 1080 * 60 =每秒124.4百万像素）高很多。现在的大多数FPGA都可以满足以这个时钟速率进行高效的处理，并且是在一个时钟周期进行一次采样的方式下运行的。对于更高分辨率的处理系统需求，如4K或2K的数字影院，或者每秒120帧甚至240帧的处理需求，就需要一个时钟周期采样更多像素点，通过增加数据处理的吞吐量方式来运行。注意，我们通常可以通过在HLS中展开循环的方式来生成此类结构（请参见1.4.2小节）。同样，当处理低分辨率和低帧率需求时，优选的方案是采用操作共享的方式，多个时钟周期去处理一次采样。这样的处理结构是通过指定循环的处理间隔方式实现。 #include ”video_common.h” unsigned char rescale(unsigned char val, unsigned char offset, unsigned char scale) { return ((val − offset) ∗ scale) >> 4; } rgb_pixel rescale_pixel(rgb_pixel p, unsigned char offset, unsigned char scale) { #pragma HLS pipeline p.R = rescale(p.R, offset, scale); p.G = rescale(p.G, offset, scale); p.B = rescale(p.B, offset, scale); return p; } void video_filter_rescale(rgb_pixel pixel_in[MAX_HEIGHT][MAX_WIDTH], rgb_pixel pixel_out[MAX_HEIGHT][MAX_WIDTH], unsigned char min, unsigned char max) { #pragma HLS interface ap_hs port = pixel_out #pragma HLS interface ap_hs port = pixel_in row_loop: for (int row = 0; row 图9.3 简单视频滤波器的实现代码 ​例如，在图9.3中代码展示了一个简单的视频处理应用程序，程序中执行每次循环的II = 1(Initiation interval),也就是一个时钟周期处理一次采样数据。代码中采用嵌套循环的方式是按照图9.1中所示的扫描线顺序处理图像中的像素。II = 3的设计方式可以通过共享计算组件的方式来减少资源使用量。通过设置内层循环展开因子为2和输入输出数组拆分因子为2就可以满足一个时钟处理两个像素。这种例子相对简单，因为每个组件和每个像素的处理是相对独立的。更复杂的功能可能不会因为资源共享而处理更方便，也可能无法同时处理多个像素。 void video_filter(rgb_pixel pixel_in[MAX_HEIGHT][MAX_WIDTH], rgb_pixel pixel_out[MAX_HEIGHT][MAX_WIDTH]) { #pragma HLS interface ap_memory port = pixel_out // The default #pragma HLS interface ap_memory port = pixel_in // The default 高速计算机视觉应用是需要满足每秒处理10000帧的200*180像素的视频帧的速度要求。这样的应用通常是使用一个高速图像传感器直接和FPGA直接连接，并且中间不需要有同步信号。在这种情况下，你会每个时钟周期内进行多少次采样处理呢？FPGA可以很好的完成处理么？答案是你可以使用HLS编写嵌套循环的结构来完成这样的设计。 9.1.3 视频处理系统架构 ​到目前为止，我们专注于构建视频处理应用部分的程序而不关心如何将其整合到一个大的系统程序中去。在很多情况下，如图9.1.2中示例代码，大部分像素处理发生在循环内，并且当循环运行时每个时钟周期仅处理一个像素。在本节中，我们将讨论讲视频处理部分程序集成到大的系统程序中的情况。 ​默认情况下，Vivado@HLS软件会将代码中的函数数组接口综合成硬件的存储器接口。其中，存储器写数据接口由地址总线、数据总线和写使能信号线组成。存储器每次读取和写入数据均有相应地址变化，并且数据读取和写入时间固定。如图9.4所示，将这种接口与片上存储资源Block RAM资源集成在一起使用很简单方便。但是即使在大容量的芯片，片上Block RAM资源也是很稀缺的，因此如果存储大容量的视频资源会很快消耗完片上Block RAM资源。 针对24位像素位深的1920x1080视频帧，芯片需要消耗多少BlockRAM资源才能完成存储存一帧视频帧？片上Block RAM资源最多又能存储多少帧呢？ void video_filter(pixel_t pixel_in[MAX_HEIGHT][MAX_WIDTH], pixel_t pixel_out[MAX_HEIGHT][MAX_WIDTH]) { #pragma HLS interface m_axi port = pixel_out #pragma HLS interface m_axi port = pixel_in ​通常，大部分视频系统更好的选择是将视频帧存储在外部存储器中，比方说DDR。在图9.5中展示了系统与外部存储器典型系统集成模式。在FPGA内部，外部存储器的控制器（MIG）集成了ARM AXI4标准化从接口与FPGA内的其他模块进行通信。FPGA内的其它模块使用AXI4主接口或者是通过专门的AXI4内部互联模块与外部存储器的AXI4从接口相连。AXI内部互联模块允许多个主设备模块访问多个从设备模块。该架构抽象了外部存储器的操作细节，允许在无需修改FPGA设计中其它模块的情况下，允许不同外部存储器模块和标准互换使用。 ​尽管大多数处理器都使用高速缓存，从而高性能处理数据。但通常情况下，如图9.5所示，基于FPGA实现的视频处理系统，无需片上高速缓存。在处理器系统中，高速缓存可以提供对先前访问的数据更低时延的访问，并通过始终读取或写入完整的高速缓存行来提高对外部存储器访问的带宽。一些处理器甚至还使用更复杂的数据处理机制，如预取和推测读取，以减少对外部存储器的访问时延和增加对外部存储器的访问带宽。对于大多数基于FPGA的视频处理系统，因为大多数视频算法访问外部存储器是可预测的，所以使用线性缓冲区和窗口缓冲区可以一次从外部缓冲区中读取多个数据。另外,当以猝发模式对外部存储器访问时，Vivado@HLS能够提前调度地址变换，避免读取数据时拖延计算。 void video_filter(pixel_t pixel_in[MAX_HEIGHT][MAX_WIDTH], pixel_t pixel_out[MAX_HEIGHT][MAX_WIDTH]) { #pragma HLS interface s_axi port = pixel_out #pragma HLS interface s_axi port = pixel_in void video_filter(pixel_t pixel_in[MAX_HEIGHT][MAX_WIDTH], pixel_t pixel_out[MAX_HEIGHT][MAX_WIDTH]) { #pragma HLS interface ap_hs port = pixel_out #pragma HLS interface ap_hs port = pixel_in void video_filter(hls::stream &pixel_in, hls::stream &pixel_out) { 图9.7: HLS中流接口的代码实现方式 如图9.6所示为另一种存储器体系架构。在这种架构中，算法处理模块通过外部直接存储器（DMA）与外部存储器连接，DMA完成与外部存储控制器（MIG）之间地址转换的细节操作。算法处理模块可以以AXI总线数据流（AXIS）的形式将数据传输给DMA控制器。DMA假设数据是算法处理模块生成的，并将数据写入外部存储器。在Vivado@HLS中，有多种编码方式可以将代码中的数组接口综合成AXIS流接口，如图9.7所示是其中一种。在这种情况下，C代码与前面看到的代码相同，但接口约束指令不同。另外一种代码实现方法是使用hls::stream<>方式显式建立总线流接口。无论那种情况都必须注意，DMA中生成数据的顺序要与C代码中访问数据的顺序相同。 ​AXIS数据流接口的一个优点是它允许在设计系统中，采用多个算法处理模块级联的方式，并且不需要在外部存储器中存储算法处理计算中间结果。在一些应用例子中，如图9.8所示，FGPA系统在没有外部存储器的情况下，将从输入接口（如HDMI）上接收到的像素数据处理后直接将它们发送到输出接口。这样的设计通常要求算法处理模块的吞吐量必须达到需求，以满足外部接口严格实时约束的要求。当一些复杂的算法构建时，系统难以保证其数据吞吐量需求，因此系统如果至少能提供一帧缓冲区，就可以为算法构建提供更大的灵活性。当输入和输出像素速率不同或者可能不相关时（例如接收任意输入视频格式并输出不同任意视频格式的系统），帧缓冲可以起到简化构建系统的作用。 void video_filter(pixel_t pixel_in[MAX_HEIGHT][MAX_WIDTH], pixel_t pixel_out[MAX_HEIGH][MAX_HEIGHT]) { #pragma HLS interface ap_hs port = pixel_out #pragma HLS interface ap_hs port = pixel_in 9.2 实现 ​当一个系统实际处理视频数据时，一般从视频处理算法实现角度来进行系统分解集成。在本章的剩余部分，我们将假设输入数据是按照流的方式送入系统，并且按照扫描线的顺序进行处理的。采用HLS开发，我们不关注代码RTL级具体实现方式，只关注HLS设计能满足所需要的性能指标要求即可。 9.2.1 行缓冲和帧缓冲 ​在视频处理算法中，通常计算一个输出像素的值时需要输入像素及其周围的像素的值做参考，我们把储存计算所需要的输入像素值的区域叫窗口。从概念上讲，按照窗口大小去Z型扫描图片，然后根据扫描到的像素值计算出输出结果就可以。如图9.9所示示例代码中，示例代码是针对视频帧进行二维滤波。示例代码中在计算每一个输出像素结果前需要从输入视频帧中读取相应的窗口像素数据（存储在数组中）。 在图9.9中，代码中包含的int wi =row + i – 1;int wj = col +j -1;, 解释这些表达式为什么包含”-1”这一项。提示：如果滤波器核换成7×7，而不是3×3，”-1”这个数字项会改变么？ ​注意，在此代码中，每计算一个输出像素值，必须多次读入像素并填充到窗口缓冲区中。如果每个时钟周期只能执行一次读操作，示例代码的执行性能会受限于读入像素速率大小。因此示例代码基本上是图1.8中所示一维滤波器的二维版本。另外，因为输入像素不是以正常扫描线顺序读取的，所以接口约束也只有有限的几个可选。（本主题将在9.1.3小节中更详细讨论）。 ​仔细观察相邻的窗口缓冲区中缓冲的数据，你会发现缓冲的数据高度重叠，这意味着相邻窗口缓冲区之间数据更高的依存性。这也意味来自输入图像的像素可以被本地缓存或者高速缓存存储，以备数据被多次访问使用。通过重构代码来每次只读取输入像素一次并存储在本地缓冲区中，这样可以使系统性能得到更好的表现。在视频系统中，由于本地缓冲区存储窗口周围多行视频像素，所以本地缓冲区也称为线性缓冲区。线性缓冲区通常使用Block RAM(BRAM)资源实现，而窗口缓冲区则使用触发器（FF）资源实现。图9.10所示是使用线性缓冲区重构的代码。注意，对于N×N图像滤波器，只需要N-1行存储在线性缓冲区中即可。 rgb_pixel filter(rgb_pixel window[3][3]) { const char h[3][3] = {{1, 2, 1}, {2, 4, 2}, {1, 2, 1}}; int r = 0, b = 0, g = 0; i_loop: for (int i = 0; i = MAX_HEIGHT || wj = MAX_WIDTH) { window[i][j].R = 0; window[i][j].G = 0; window[i][j].B = 0; } else window[i][j] = pixel_in[wi][wj]; } } if (row == 0 || col == 0 || row == (MAX_HEIGHT − 1) || col == (MAX_WIDTH − 1)) { pixel_out[row][col].R = 0; pixel_out[row][col].G = 0; pixel_out[row][col].B = 0; } else pixel_out[row][col] = filter(window); } } } 图9.9: 没有使用线性缓冲区的2D滤波代码 ​如图9.10所示代码，是使用线性缓冲区和窗口缓冲区方式实现的，其中代码实现过程如图9.11所示。代码每次执行一次循环时，窗口会移动一次，使用来自于1个输入像素和两个来自于行缓冲区缓存的像素来填充窗口缓冲区。另外，输入的新像素被移入线性缓冲区，准备被下一行的窗口运算过程所使用。请注意，由于为了每个时钟周期处理一个像素并输出结果，所以系统必须在每个时钟周期内完成对窗口缓冲区数据的读取和写入。另外，当展开”i”循环后，对于窗口缓冲区数组而言，每个数组索引都是一个常量。在这种情况下，Vivado@HLS将转换数组中的每个元素成一个标量变量（一个成为标量化的过程）。窗口数组中的元素随后使用触发器(FF)编译实现。同样，线性缓冲区的每一行数据都会被访问两次（被读取一次和写入一次）。示例代码中明确约束行缓冲区中每一行数组元素被分割成到一块单独存储区中。根据MAX WIDTH的可能取值情况，最后决定使用一个或者多个Block RAM实现。注意，每个Block RAM可在每个时钟周期支持两次独立访问。 线性缓冲区是应用于模块式计算的重用缓冲区的一种特殊例子。如图9.9中所示，重用缓冲区和线性缓冲区的高级综合是目前一个热点研究领域。参考[8, 31]。 Vivado@HLS包含hls::linebuffer<>和hls::window buffer<>类，它们可以简化窗口缓冲区和行缓冲区的管理。 对于3×3的图像滤波器核，则存储每个像素占用4字节的1920×1080图像的一行数据需要使用多少个FPGA片上Block RAM? 9.2.2 因果滤波器 ​图9.10中实现的滤波器是每个时钟周期读取一个输入像素，计算出一个输出像素。该滤波器实现原理与图9.9中所示不完全相同。输出结果是从先前读取像素的窗口缓冲区中数据计算出来的。窗口缓冲区中取数顺序是“向上和向左”。因此，输出图像相对于输入图像是“向下和向右”移动的。这种情况类似于信号处理中的因果滤波器和非因果滤波器的原理。大多数信号处理理论的重点是因果滤波器。因为只有因果滤波器对于时间采样信号（例如，其中x[n]=x(n∗T)x[n] = x(n*T)x[n]=x(n∗T)和​y[n]=y(n∗T)y[n] = y(n*T)y[n]=y(n∗T)）才有实用价值。 在因果滤波器 void video_2dfilter_linebuffer(rgb_pixel pixel_in[MAX_HEIGHT][MAX_WIDTH], rgb_pixel pixel_out[MAX_HEIGHT][MAX_WIDTH]) { #pragma HLS interface ap_hs port=pixel_out #pragma HLS interface ap_hs port=pixel_in rgb_pixel window[3][3]; rgb_pixel line_buffer[2][MAX WIDTH]; #pragma HLS array_partition variable=line_buffer complete dim=1 row_loop: for (int row = 0; row 图 9.10: 使用线性缓冲区实现2D滤波器的代码 通过卷积的定义证明前面原理： y=x⊗h:y[n]=∑k=−∞∞x[k]∗h[n−k]y = x \\otimes h:y[n] = \\sum\\limits_{k = - \\infty }^\\infty {x[k]*h[n - k]} y=x⊗h:y[n]=k=−∞∑∞​x[k]∗h[n−k] ​就本书而言，大多数变量不是时间采样信号和单输入单输出系统。对于设计时间采样信号的系统，在使用HLS开发过程中可以进行时序约束处理。只要系统能达到所需的任务延迟，那么就认为系统设计是正确的。 ​在大多数视频处理算法中，在上文代码中所引入的空间位移不是预期的，是需要被消除的。虽然有很多种修改代码的方法来解决这个问题，但是一种常见的方式是扩展迭代域。这种技术是通过增加少量的循环边界，以便第一次循环迭代就读取第一个输入像素，但是第一个输出像素直到等到后面的迭代空间才写出。修改后的版本滤波器代码如图9.12所示。代码原理如图9.14所示，和图9.10中原始缓冲区中代码相同。使用HLS编译后，可以看出数据依赖性以完全相同的方式得到满足，并且待综合的代码是硬件可实现的。 9.2.3 边界条件 ​在大多数情况下，计算缓冲区窗口只是输入图像的一个区域。然而，在输入图像的边界区域，滤波器进行计算的范围将超过输入图像的边界。根据不同应用的要求，会有很多不同的方法来解决图像边界处的计算问题。也许最简便的方法来解决边界问题就是忽略边界，这样输出的图像就会比输入的图像长宽各少滤波器核大小。但是在输出图像大小固定的应用中，如数字电视，这种方法就行不通了。 void video_2dfilter_linebuffer_extended( rgb_pixel pixel_in[MAX_HEIGHT][MAX_WIDTH], rgb_pixel pixel_out[MAX_HEIGHT][MAX_WIDTH]) { #pragma HLS interface ap_hs port=pixel_out #pragma HLS interface ap_hs port=pixel_in rgb_pixel window[3][3]; rgb_pixel line_buffer[2][MAX_WIDTH]; #pragma HLS array_partition variable=line_buffer complete dim=1 row_loop: for(int row = 0; row = 1 && col >= 1) { int outrow = row−1; int outcol = col−1; if(outrow == 0 || outcol == 0 || outrow == (MAX_HEIGHT−1) || outcol == (MAX_WIDTH−1)) { pixel_out[outrow][outcol].R = 0; pixel_out[outrow][outcol].G = 0; pixel_out[outrow][outcol].B = 0; } else { pixel_out[outrow][outcol] = filter(window); } } } } } ​图 9.12: 使用线性缓冲区并且循环迭代范围扩展为1时实现2D的滤波器代码 另外，当处理大量大小略微不同的图片时，需要一系列大小的滤波器核来进行处理，这种情况就复杂了。图9.10中的代码展示，输出图像通过在边界处填充已知值的像素（一般填充黑色）来达到与输入图像大小相同。或者通过其他方式来合成缺失的值。 缺少的输入值可以用常量来填充； 可以从输入图像的边界像素处填充缺少的输入值； 缺失的输入值可以在输入图片内部像素中进行重构。 当然，也存在更复杂和更计算密集的方案。图9.16中展示了一种处理边界条件的方案。此方案是通过计算每个像素在窗口缓冲区中的偏移地址方法。这种方案的一个明显的缺点就是每次从窗口缓冲区中读取的地址都是变化的地址。因此，在计算滤波之前，这个变量会导致多路复用。对于N×N的抽头滤波器，针对N个输入将会消耗大约N×N个多路复用器。对于滤波器而言，多路复用器占滤波器资源消耗的大部分。另一种处理数据写入窗口缓冲区时的边界条件是以规则模式移动窗口缓冲区。在这种情况下，只消耗N个多路复用器，而不是N*N个，从而是资源消耗量降低很多。 修改图9.16中的代码，从窗口缓冲区中读取数据使用常量地址。你节省了多少硬件资源？ 9.3 结论 ​视频处理是一种常见的非常适合使用HLS实现的FPGA应用。大多数视频处理算法有一个共同特点是数据局部性，即可以在使用少量的外部存储器访问的情况下，能够实现流式传输和本地缓存的应用。 void video 2dfilter linebuffer extended constant( rgb pixel pixel in[MAX HEIGHT][MAX WIDTH], rgb pixel pixel out[MAX HEIGHT][MAX WIDTH]) { #pragma HLS interface ap hs port=pixel out #pragma HLS interface ap hs port=pixel in rgb pixel window[3][3]; rgb pixel line buffer[2][MAX WIDTH]; #pragma HLS array partition variable=line buffer complete dim=1 row loop: for(int row = 0; row = 1 && col >= 1) { int outrow = row−1; int outcol = col−1; rgb pixel window2[3][3]; for (int i = 0; i = MAX HEIGHT − outrow + 1) wi = MAX HEIGHT − outrow; else wi = i; if (j = MAX WIDTH − outcol + 1) wj = MAX WIDTH − outcol; else wj = j; window2[i][j] = window[wi][wj]; } } pixel out[outrow][outcol] = filter(window2); } } } } 图9.16: 使用线性缓冲区核常量边界来实现处理边界条件的代码，这种方法处理消耗硬件资源成本很大 Copyright © xupsh.github.io 2018 all right reserved，powered by Gitbook 该文件修订时间： 2018-06-18 15:09:08 "},"10-Sorting-Algorithms.html":{"url":"10-Sorting-Algorithms.html","title":"第十章","keywords":"","body":"第十章 Copyright © xupsh.github.io 2018 all right reserved，powered by Gitbook 该文件修订时间： 2018-06-18 15:09:08 "},"11-Huffman-Encoding.html":{"url":"11-Huffman-Encoding.html","title":"第十一章","keywords":"","body":"第十一章 Copyright © xupsh.github.io 2018 all right reserved，powered by Gitbook 该文件修订时间： 2018-06-18 15:09:08 "},"GLOSSARY.html":{"url":"GLOSSARY.html","title":"词汇表汇总","keywords":"","body":"Glossary array partitioning Dividing a single logical array into multiple physical memories. bitstream The configuration data used to program the functionality of an FPGA. BRAM A block RAM is a configurable random access memory that is embedded throughout an FPGA for data storage and communication. C/RTL cosimulation The process of verifying an RTL design generated by HLS using testvectors captured from the C testbench. Compressed Row Storage Compressed Row Storage is a technique for representing a sparse matrix. It allows large matrices with a small number of elements to be stored and operated on eficiently. data rate The frequency at which a task can process the input data. This is often expressed in bits/second and thus also depends on the size of the input data Discrete Fourier Transform An transformation that takes a discrete signal and converts it to a freqeuncy-domain representation. EDA Electronic design automation (EDA) are a set of software tools used to aid the hardware design process. Fast Fourier Transform An optimized version of the Discrete Fourier Transform (DFT) which requires fewer operations. FF A flip-flop (FF) is a circuit that can store information. We typically think of it as storing one bit of data and are a fundamental building block for creating memories in digital circuits. finite impulse response A common digital signal processing task that performs a convolution on the input signal with a fixed signal that is defined by its coeffcients. The FIR is often performed in hardware and can be efficiently implemented. FPGA A field-programmable gate array (FPGA) is an integrated circuit that can be customized or programmed after it is manufactured (\"in the field\"). HLS High-level synthesis is a hardware design process that translates an algorithmic description (which is decoupled from the cycle to cycle behavior) into a register transfer level (RTL) hardware description language which specfi\fes the exact behavior of the circuit on a cycle-by- cycle basis I/O block An I/O block provides the interface between the FPGA fabric and the remainder of the system. I/O blocks can talk to memories (e.g., on-chip caches and off-chip DRAM, microprocessors (using AXI or other protocols), sensors, actuators, etc. IP core An RTL-level component with well-de\fned interfaces enabling it to be incorporated into a larger design. Often used as a way of hiding the `intellectual property' from another company, hence the name. logic synthesis The process of converting an glsrtl design into a netlist of device-level primitives. loop interchange A code transformation that changes the order of loop operations. This transformation is often a useful approach to addressing recurrences in code. loop pipelining Enabling multiple iterations of a loop to run concurrently sharing the same func-tional units. LUT A lookup table (LUT) is a memory where the address signal are the inputs and the corresponding outputs are contained in the memory entries. It is a key computational component of modern\feld-programmable gate array (FPGA)s. netlist An intermediate design artifact consisting of device-level primitive elements and the connections between them. In FPGA designs, the primitive elements include lookup table (LUT)s, flip-flip (FF)s, and block RAM (BRAM)s. partial loop unrolling A transformation where the body of a loop is replicated multiple times. This is often used in processor systems to reduce loop condition overhead or to provide opportunities for vectorization. In HLS, it can have a similar effect, enabling more operations from the same loop nest to be considered in scheduling. This can improve the performance of a design. place and route The process of converting a netlist of device-level primitives into the con\fguration of a particular device. process An individual component in a dataflow architecture processing element A coarse-grained concurrently executing component in a design. In HLS, this is often used in the context of a data flow design. recurrence A code structure that results in a feedback loop when implemented in a circuit. Recurrences limit the throughput of the circuit. ROM A Read-only Memory is a memory which is initialized to a particular value and then read but never written. In many cases the storage for ROMs can be highly optimized because their value never changes. routing channel A routing channel provides a exible set of connections between the FPGA programmable logic elements. RTL Register-transfer level (RTL) is a hardware design abstraction which models a synchronous digital circuit using logical operations that occur between between hardware registers. It is common design entry for modern digital design slice A (typically small) set of LUTs, FFs and multiplexors. These are often reported in FPGA resource utilization reports. sorting cell An simple stateful component that forms part of a larger sorting network or algorithm. Commonly a cell performs a compare-and-swap operation between two elements. stable sort A sorting algorithm that keeps different elements with the same sorting key in their original sequence after sorting. Static Single Assignment Static Single Assignment is an intermediate representation in compilers where each variable is assigned only once. This form makes many common optimizations simpler to write. switchbox A switchbox connects routing channels to provide a flesible routing structure for data routed between the programmable logic and I/O block. systolic array An array of processing elements that coordinate to perform a more complex algorithm. Systolic arrays are usually designed so that each processing element encapsulates some local information and only communicates with its local neighbors. This often enables systolic arrays to easily scale to large problem sizes by increasing the size of the array. task A fundamental atomic unit of behavior or high-level synthesis computation; this corresponds to a function invocation in high-level synthesis task pipelining Being able to execute more than one task concurrently on the same accelerator in a pipelined fashion. task interval The time between when one task starts and the next starts or the difference between the start times of two consecutive tasks task latency The time between when a task starts and when it finishes Copyright © xupsh.github.io 2018 all right reserved，powered by Gitbook 该文件修订时间： 2018-06-18 15:09:08 "},"BIBLIOGRAPHY.html":{"url":"BIBLIOGRAPHY.html","title":"参考文献","keywords":"","body":"参考文献 45 Ameer M.S. Abdelhadi and Guy G.F. Lemieux. Modular multi-ported SRAM-based memories. In Proceedings of the International Symposium on Field Programmable Gate Arrays (FPGA), pages 35{44. ACM, 2014. ISBN 978-1-4503-2671-1. doi: 10.1145/2554688.2554773. URL http://doi.acm.org/10.1145/2554688.2554773. 55 Ameer M.S. Abdelhadi and Guy G.F. Lemieux. Modular multi-ported SRAM-based memories. In Proceedings of the International Symposium on Field Programmable Gate Arrays (FPGA), pages 35{44. ACM, 2014. ISBN 978-1-4503-2671-1. doi: 10.1145/2554688.2554773. URL http://doi.acm.org/10.1145/2554688.2554773. Copyright © xupsh.github.io 2018 all right reserved，powered by Gitbook 该文件修订时间： 2018-06-18 15:09:08 "},"RULES.html":{"url":"RULES.html","title":"排版约定","keywords":"","body":"排版约定 引用公式 使用示例: Inline math: ∫−∞∞g(x)dx\\int_{-\\infty}^\\infty g(x) dx∫−∞∞​g(x)dx Block math: ∫−∞∞g(x)dx(4.1) \\int_{-\\infty}^\\infty g(x) dx \\quad (4.1) ∫−∞∞​g(x)dx(4.1) 引用代码 只要将代码用```包住，代码块就会被识别为代码 ```c #include \"huffman.h\" // Postcondition: out[x].frequency > 0 void filter( /* input */ Symbol in[INPUT_SYMBOL_SIZE], /* output */ Symbol out[INPUT_SYMBOL_SIZE], /* output */ int *n) { #pragma HLS INLINE off ap_uint j = 0; for(int i = 0; i #include \"huffman.h\" // Postcondition: out[x].frequency > 0 void filter( /* input */ Symbol in[INPUT_SYMBOL_SIZE], /* output */ Symbol out[INPUT_SYMBOL_SIZE], /* output */ int *n) { #pragma HLS INLINE off ap_uint j = 0; for(int i = 0; i 引用图片 在行文中使用下述格式引用图片，将图片下方的备注写在[]之间 ![Figure 5.1: Part a) is a data flow graph for a 2 point DFT/FFT. Part b) shows the same compu-tation, but viewed as a butterfly structure. This is a common representation for the computation of an FFT in the digital signal processing domain.](images/2pointFFT.jpg) 文字加框 原书中蓝色的框 {% hint style='info' %} Important info: this note needs to be highlighted {% endhint %} Important info: this note needs to be highlighted 原书中黑色的框 {% hint style='tip' %} Important tip: this note needs to be highlighted {% endhint %} Important tip: this note needs to be highlighted 其它 请酌情使用 {% hint style='danger' %} Important danger: this note needs to be highlighted {% endhint %} Important danger: this note needs to be highlighted {% hint style='working' %} Important working: this note needs to be highlighted {% endhint %} Important working: this note needs to be highlighted 引用参考文献 在行文中使用下述格式引用参考文献即可 [[45](./BIBLIOGRAPHY.md#45), [55](./BIBLIOGRAPHY.md#55)] [45, 55] Copyright © xupsh.github.io 2018 all right reserved，powered by Gitbook 该文件修订时间： 2018-06-18 15:09:08 "}}