{"./":{"url":"./","title":"README","keywords":"","body":"pp4fpga-cn 中文版 Parallel Programming for FPGAs 电子书阅读地址: https://xupsh.github.io/pp4fpgas-cn 电子书下载地址: pdf 写在前面 国内鲜有介绍HLS的书，我们希望通过翻译Parallel Programming for FPGAs这本书，让更多的人来了解HLS和FPGA开发。 翻译之前 Parallel Programming for FPGAs这本书的原作采用的是latex进行内容的编写和排版。为了提高翻译写作的速度和协作的效率，本次翻译任务选择了在GitHub这个平台上进行协作，采用了Markdown使得译者可以专注文字内容而不是排版样式，安心写作。 这也给参与翻译任务的诸位带来了一点小挑战，需要诸位事先熟悉一下GitHub平台的使用、git的使用以及Markdown语言的规范，下面是相关的参考链接给诸位快速上手。 翻译规范 翻译规范 编辑器 一个界面美观、交互UI设计良好的编辑器可以帮我们节省很多力气，这里我们比较推荐使用以下几款编辑器来进行翻译工作 Atom VS Code Markdown语言 事实上这篇README就是用Markdown写成的 :) 认识与入门Markdown Markdown 语法说明 (简体中文版) git git可以说是现在最为流行的版本管理工具了。 廖雪峰的git教程 猴子都能懂的GIT入门 其实最常用的命令无非下面几条 下载git库到本地 git clone https://github.com/xupsh/pp4fpgas-cn.git 保存本地的修改并上传到云端服务器(GitHub) git add -A git commit -m \"最近的修改里都做了什么\" git pull git push GitHub的Pull Request操作 在GitHub上进行协作，通常采用的方式是先各自fork一份到自己的个人帐户，经过一段时间的工作之后，通过pull request的方式，将自己的工作内容提交到公共项目帐户中，而pull request之后往往还需要进行review才能正式进入公共项目。 github的pull request官方文档 Pull Request 的流程 第一步，你需要把别人的代码，克隆到你自己的仓库，Github 的术语叫做 fork。 第二步，在你仓库的修改后的分支上，按下\"New pull request\"按钮。 这时，会进入一个新页面，有Base 和 Head 两个选项。Base 是你希望提交变更的目标，Head 是目前包含你的变更的那个分支或仓库。 第三步，填写说明，帮助别人理解你的提交，然后按下\"create pull request\"按钮即可。 PR 创建后，管理者就要决定是否接受该 PR。对于非代码变更（比如文档），单单使用 Web 界面就足够了。但是，对于代码变更，Web 界面可能不够用，需要命令行验证是否可以运行。 任务分工 章节 译者 校对 00 Preface 01 Introduction 02 Finite Impulse Response(FIR) Filters 03 CORDIC 04 Discrete Fourier Transform 05 Fast Fourier Transform 06 Sparse Matrix Vector Multiplication 07 Matrix Multiplication 08 Prefix Sum and Histogram 09 Video System 10 Sorting Algorithms 11 Huffman Encoding Citation @ARTICLE{ 2018arXiv180503648K, author = {{Kastner}, R. and {Matai}, J. and {Neuendorffer}, S.}, title = \"{Parallel Programming for FPGAs}\", journal = {ArXiv e-prints}, archivePrefix = \"arXiv\", eprint = {1805.03648}, keywords = {Computer Science - Hardware Architecture}, year = 2018, month = may } Copyright © github.com/xupsh 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 15:24:12 "},"00-Preface.html":{"url":"00-Preface.html","title":"前言","keywords":"","body":"前言 \"当有人说‘我想要一个编程语言，这个语言我只需要直接写我要干什么’的时候，你还是给他一个棒棒糖吧。\" -Alan Perlis     本书将着重介绍高层次综合（HLS） 算法的使用并以此完成一些比较具体、细分的FPGA应用。我们的目的是让读者认识到用HLS创造并优化硬件设计的好处。当然，FPGA的并行编程肯定是有别于在多核处理器、GPU上实行的并行编程，但是一些最关键的概念是相似的，例如，设计者必须充分理解内存层级和带宽、空间局部性与时间局部性、并行结构和计算与存储之间的取舍与平衡。     本书将更多的作为一个实际应用的向导，为那些对于研发FPGA系统有兴趣的读者提供帮助。对于大学教育来说，这本书将更适用于高阶的本科课程或研究生课程，同时也对应用系统设计师和嵌入式程序员有所帮助。我们不会对C/C++方面的知识做过多的阐述，而会以提供很多的代码的方式作为示范。另外，读者需要对基本的计算机架构有所熟悉，例如流水线（pipeline），加速，阿姆达尔定律（Amdahl's Law）。以寄存器传输级（RTL)为基础FPGA设计知识并不是必需的，但会对理解本书有所帮助。     本书囊括了很多对教学很有帮助的内容。每个章节均有一些小问题留给读者，这些问题将有助于加深对于材料的理解。在加州大学圣地亚哥分校（UCSD）的CSE 237C这门课里也有很多用HLS开发的项目，如果有出于教育目的的需要，我们可以对提出申请的读者分享这些课程项目的文件。这些HLS项目主要是与数字信号分析相关，重点于无线交流系统的开发。每个单独的项目都或多或少与书中的某一章节有所关联。这些项目以赛灵思大学计划（Xilinx University Program）使用的FPGA开发板为基础而开发，设计基础参考 http://www.xilinx.com/support/university.html 。赛灵思也同时提供这些开发板的商业订单。同时我们鼓励读者在 http://xilinx.com 申请Vivado HLS的试用许可。     本书并不着重于HLS算法本身。HLS处理方面的具体内容已经有很多的资源供读者参考，包括计划，资源分配，捆绑[51, 29, 18, 26]的算法。 本书更多的将会是引导学生掌握各类算法怎样分明的协同工作，提供具体的HLS语言开发程序的使用案例，因此，其他的一些更注重于算法与概念本身的材料会对理解本书很有帮助。本书也不着重于FPGA的细分结构和RTL设计方法，但是同样这方面的材料可以作为很好的辅助材料。     本书将主要使用赛灵思的Vivado HLS来完成类C代码到RTL的转换，C语言下的示例是针对Vivado HLS语法而完成的。本书不仅将介绍Vivado HLS的具体使用，而且会介绍那些最基本的HLS概念，这些概念应当适用于所有开发工具。我们同时鼓励读者尝试其他工具以真正理解这些概念，而不仅仅是在我们使用的工具里“学会”如何一步步操作。    希望你能享受这本书，并祝一切好运。 Copyright © github.com/xupsh 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 15:24:12 "},"01-Introduction.html":{"url":"01-Introduction.html","title":"第一章","keywords":"","body":"第一章 介绍 1.1   高层次综合（HLS)    　硬件设计与处理近几年来发展迅速。 过去我们的电路相对简单，硬件设计师们可以很方便的画出每一个晶体管，规划他们的连接方式，甚至他们的板上位置。可以说所有工作都是人工完成的。但随着越来越多晶体管的设计需要，硬件工程师也越来越需要依赖自动化设计工具来帮助他们完成设计，而这些设计工具也相对应的变得越来越精密。工程师在这些设计工具的协助下也更具效率。他们不再具体操作每一个晶体管，而只需要设计数字电路，电子设计自动化工具（EDA）把这些抽象而概括的电路自动转换成实际的部件构造版图。    　米德和康威（Mead&Conway）的方法[50]，也就是使用一种硬件语言描述语言（Verilog, VHDL），并把其编译成片上设计的方法在上世纪80年代开始广为使用。但这之后硬件的复杂度还在以指数函数的增长速度发展，硬件工程师们只好寻求更加概括而高层的编程语言，RTL应运而生。在RTL里，设计师不需要考虑怎么构造一个寄存器或怎样安置这些寄存器，而只需要考虑这些寄存器在设计中起到怎样的作用。EDA工具可以先把RTL转化成数电模型，再由模型转换成一个设备上的具体电路实施方案。所谓“方案”其实就是编译出的文件，这些文件可以用于规定某个自定义设备，也可以用于编程一些现有的设备，比如FPGA。如我们现在所见，新的设计方法确实帮助工程师们的设计思路变得更加清晰。更多关于这方面的探讨参考注释[42].    　HLS则是在这基础上更高层的一种方法，设计师们在HLS下需要更多的考虑大的架构而非某个单独部件或逐周期运行。设计师在HLS下需要注重的是系统的运行模式，HLS工具会负责产生具体的RTL微结构。最早大多数HLS工具是基于Verilog的，用户需要使用Verilog语言进行描述，工具也通过Verilog产生RTL。现如今很多HLS工具开始使用C/C++作为设计师端的语言。当然，选择HLS工具最重要的还是看它能否综合我们需要的程序，而不是它使用什么语言。     总体来说，HLS可以自动完成以下曾经需要手动完成的工作： HLS自动分析并利用一个算法中潜在的并发性 HLS自动在需要的路径上插入寄存器，并自动选择最理想的时钟 HLS自动产生控制数据在一个路径上出入方向的逻辑 HLS自动完成设计的部分与系统中其他部分的接口 HLS自动映射数据到储存单位以平衡资源使用与带宽 HLS自动将程序中计算的部分对应到逻辑单位，在实现等效计算的前提下自动选取最有效的实施方式     HLS的目标是根据用户提供的输入和限制自动替用户做出很多决定。每个HLS工具在实际施行的效率上相差甚远，这其中我们有一些非常不错的选择，例如赛灵思Vivado HLS, LegUp, Mentor Catapult HLS。他们出众的特性在于可以支持更多更广泛的程序转换。我们在本书中将使用Vivado HLS作为演示软件，但是设计的思路与技巧在各个软件中应当是通用的，读者只需要在各自的软件中对语法进行稍微的调整。     大多数HLS工具需要用户提供功能的规范，交互的描述，一个对接的计算设备，和目标优化方向。而对于Vivado HLS来说，用户需要： 一个用C/C++/System C编写的函数 一个测试平台用于验证结果 一个FPGA开发版 期望的时钟周期 一个简单的实施指导     HLS工具没有强大到可以处理任何代码。很多我们平时在软件编程中常用的概念在硬件实施中很难实现，所以硬件描述语言对于具体实施会更加灵活。通常这些HLS工具需要用户提供一些附加信息（通过suggestion或#pagma）来帮助完善程序，因此我们说HLS工具会同时“限制”又“加强”了一门语言。举例而言，HLS工具一般无法处理动态内存分配，大部分工具对标准库的支持也非常有限。用户也应当避免系统调用和递归以尽量降低复杂程度。除去这些设计限制之外，HLS工具的处理范围非常的广（包括直接内存访问，流，片上内存），优化效率也很高。     根据Vivado HLS的使用指南，我们将对我们的输入程序作出以下规范： 不使用动态内存分配（不使用malloc(),free(),new和delete()） 减少使用指针对指针的操作 不使用系统调用（例如abort(),exit(),printf()），我们可以在其他代码例如测试平台上使用这些指令，但是综合的时候这些指令会被无视（或直接删掉） 减少使用其他标准库里的内容（支持math.h里常用的内容，但还是有一些不兼容） 减少使用C++中的函数指针和虚拟函数 不使用递归方程 精准的表达我们的交互接口     当RTL级的设计可用时，大多数HLS工具会进行标准RTL设计流。而在赛灵思Xilinx Vivado设计套装里进行的是逻辑综合，将RTL级设计转换成一个FPGA逻辑部件的连线表，这份连线表不仅包含需要的逻辑部件还包含他们的连接方式。Vivado之后将连线表和目标设备中的可用资源相关联，这个过程被称作布局及布线（PAR）。产出的FPGA配置被附在比特流（bitstream）上，用户可以将比特流上传到FPGA以实现想要的功能。比特流实质上是用二进制表示FPGA上每一个可用资源的配置，包括逻辑部件的使用，连线的方式，和片上的内存。大型FPGA例如赛灵思UltraScale FPGA拥有超过十亿个可配置比特，较小的FPGA上也至少有几亿个可配置比特。 1.2   FPGA构造     了解HLS的第一步是熟悉FPGA的构造，因为很多HLS的优化都是和这些构造特点息息相关的。过去几十年来，FPGA变得越发大而复杂，也加入了片上内存、自定义数据路径，高速I/O，和多核处理器等等精密结构。在这一节，我们只讨论FPGA中与HLS相关的结构特点，其他无关内容不会被详细描述。了解FPGA的现代结构后再学习HLS会有助于读者对于其理解。     FPGA由一个可编程逻辑模块的矩阵和与之相连的内存组成，通常这些模块是以查找表（LUT）的形式存在，也就是说把地址信号输入进去，对应内存位置的内容会直接被输出出来。一个N位查找表可以以一个N位输入真值表的方式来表示。     上图中的a部分是一个2位输入查找表，共有 个配置比特。使用者通过编写程序来控制这些比特以实现某种功能。b部分是一个2位输入AND门的真值表，通过对应4个可能的结果产出（out一列），我们可以把a中的2位查找表编写成b中的AND门，即四个查找表输入依次对应b中的00，01，10，11。按照这个模式编写查找表，我们可以轻松的改变它的功能，让它充当我们需要的部件。对于小的布尔逻辑（Boolean），这样的编写方式更加的灵活高效。实际中的FPGA大多使用4-6位输入的查找表作为运算基础，一些大型FPGA内甚至有几百万个这一级别的查找表。 Copyright © github.com/xupsh 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 15:24:12 "},"02-Finite-Impulse-Response-Filters.html":{"url":"02-Finite-Impulse-Response-Filters.html","title":"第二章","keywords":"","body":"第二章 Copyright © github.com/xupsh 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 15:24:12 "},"03-CORDIC.html":{"url":"03-CORDIC.html","title":"第三章","keywords":"","body":"第三章 Copyright © github.com/xupsh 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 15:24:12 "},"04-Discrete-Fourier-Transform.html":{"url":"04-Discrete-Fourier-Transform.html","title":"第四章","keywords":"","body":"第四章 离散傅里叶变换     离散傅里叶变换（DFT）在数字信号处理系统中发挥着重要作用。它是一种将离散信号从时域变换到频域的方法。 通过将信号描述为正弦波的总和，我们才可以更容易地在信号上实现函数计算，例如滤波和其他线性时不变函数。 因此，离散傅里叶变换在许多无线通信，图像处理和其他数字信号处理应用中占据重要地位。　     本章介绍了DFT，并将重点放在了介绍了DPT在FPGA实现中的算法优化。DFT运算的核心是以一组固定系数执行矩阵向量乘法。在4.6章节中，我们首先将DFT运算初始优化集中在将其简化为矩阵 - 向量乘法，随后介绍了DFT使用Vivado HLS代码的完整实现方式。 另外，我们也描述了如何最佳地优化DFT计算以增加吞吐量。第4.5章中，我们将的优化工作集中在阵列分区优化上。     本章的前两小节有大量的数据计算和推导，这可能看起来有些多余，但是它对于我们充分理解代码重构优化以下一章快速傅里叶变换的对称性计算有着很大作用。但是如果你对HLS 优化内容更感兴趣，可以直接跳至第4.6章开始阅读。 4.1   傅里叶级数     为了解释离散傅里叶变换，我们首先要了解傅里叶级数。傅立叶级数提供了一种可选方法来观察信号从-π到π的一个周期内的连续实值周期信号。Jean Baptiste Joseph Fourier的开创性成果表明，在2π周期内任何连续的周期性信号都可以用周期为2π的余弦和正弦和表示。最终，傅里叶级数的表现形式如下： \\sim\\frac{a{0}}{2}%2Ba{1}cos(t)%2Ba{2}cos(2t)%2Ba{3}cos(3t)%2B\\cdots\\.b{1}sin(t)%2Bb{2}sin(2t)%2Bb_{3}sin(3t)%2B\\cdots)     其中参数和的计算公式如下： dt) cos(nt)dt) sin(nt)dt)    有几个需要注意的点是：首先式4.2中的参数,被称作傅里叶参数。其中参数被称作直流分量（来自于对早期电流分析的参考），其中n=1频率分量称为基波，而其他频率（n≥2）分量统称为高次谐波。 基波和高次谐波的概念来自声学和音乐。其次，函数f以及cos()和sin()函数都有2π个周期; 我们很快就会展现如何将这个周期改变为其他值。直流分量等同于cos(0·t)=1时的系数，因此使用符号a。因为sin(0·t)=0，所以不需要的值。最后，在某些情况下，函数f和它的傅里叶级数之间是近似相等的关系，这种不连续的现象我们称之为吉布斯现象。而这是只是一个仅与傅里叶级数有关的小问题，与其他傅立叶变换无关。 因此，今后我们将忽略式[4.1]中的“近似”（〜），直接视为“相等”（=）。    表示除π以外的周期性函数需要对变量进行简单的更改。 假设一个函数的周期范围在[-L,L]而不是[-π,π],则设：     以及     这是一个简单地将周期区间从[-π,π]变换到期望的[-L,L]的一个线性方程，将代入到式4.1得： =\\frac{a{0}}{2}%2B{\\sum{n=1}^{\\infty}}(a{n}cos(\\frac{n\\pi{t^{'}}}{L})%2Bb{n}sin(\\frac{n\\pi{t^{'}}}{L}))) 用同样的方法解得a和b的各项参数可解得： dt^{'}) cos(\\frac{n\\pi{t^{'}}}{L})dt^{'}) sin(\\frac{n\\pi{t^{'}}}{L})dt^{'}) 我们也可以利用欧拉公式+jsin(nt))来得出一个更简洁的公式。 =\\sum{n={-\\infty}}^{\\infty}c{n}e^{jnt}) 其中，傅里叶参数是一个较为复杂的指数表达式： e^{-jnt}dt) 假设f(t)是一个具有2π个周期的周期函数，将这个公式与式4.1等效，傅里叶参数之间的数值关系为: forn=0,1,2,\\cdots) forn=0,1,2,\\cdots) Copyright © github.com/xupsh 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 15:24:12 "},"05-Fast-Fourier-Transform.html":{"url":"05-Fast-Fourier-Transform.html","title":"第五章","keywords":"","body":"第五章 Copyright © github.com/xupsh 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 15:24:12 "},"06-Sparse-Matrix-Vector-Multiplication.html":{"url":"06-Sparse-Matrix-Vector-Multiplication.html","title":"第六章","keywords":"","body":"第六章 Copyright © github.com/xupsh 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 15:24:12 "},"07-Matrix-Multiplication.html":{"url":"07-Matrix-Multiplication.html","title":"第七章","keywords":"","body":"第七章 Copyright © github.com/xupsh 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 15:24:12 "},"08-Prefix-Sum-and-Histogram.html":{"url":"08-Prefix-Sum-and-Histogram.html","title":"第八章","keywords":"","body":"第八章 Copyright © github.com/xupsh 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 15:24:12 "},"09-Video-Systems.html":{"url":"09-Video-Systems.html","title":"第九章","keywords":"","body":"第九章 Copyright © github.com/xupsh 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 15:24:12 "},"10-Sorting-Algorithms.html":{"url":"10-Sorting-Algorithms.html","title":"第十章","keywords":"","body":"第十章 Copyright © github.com/xupsh 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 15:24:12 "},"11-Huffman-Encoding.html":{"url":"11-Huffman-Encoding.html","title":"第十一章","keywords":"","body":"第十一章 Copyright © github.com/xupsh 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 15:24:12 "},"GLOSSARY.html":{"url":"GLOSSARY.html","title":"词汇表汇总","keywords":"","body":"Glossary array partitioning Dividing a single logical array into multiple physical memories. bitstream The con\fguration data used to program the functionality of an FPGA. BRAM A block RAM is a con\fgurable random access memory that is embedded throughout an FPGA for data storage and communication. Copyright © github.com/xupsh 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 15:24:12 "},"BIBLIOGRAPHY.html":{"url":"BIBLIOGRAPHY.html","title":"参考文献","keywords":"","body":"参考文献 45 Ameer M.S. Abdelhadi and Guy G.F. Lemieux. Modular multi-ported SRAM-based memories. In Proceedings of the International Symposium on Field Programmable Gate Arrays (FPGA), pages 35{44. ACM, 2014. ISBN 978-1-4503-2671-1. doi: 10.1145/2554688.2554773. URL http://doi.acm.org/10.1145/2554688.2554773. 55 Ameer M.S. Abdelhadi and Guy G.F. Lemieux. Modular multi-ported SRAM-based memories. In Proceedings of the International Symposium on Field Programmable Gate Arrays (FPGA), pages 35{44. ACM, 2014. ISBN 978-1-4503-2671-1. doi: 10.1145/2554688.2554773. URL http://doi.acm.org/10.1145/2554688.2554773. Copyright © github.com/xupsh 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 15:24:12 "},"RULES.html":{"url":"RULES.html","title":"规范","keywords":"","body":"规范 引用公式 deprecated 在http://chart.googleapis.com/chart?cht=tx&chl=\\Large%20后面直接加上latex公式即可生成对应公式的图片。 注意[]中写的是公式的编号，请确保下面的链接可以在浏览器中直接访问。 Latex常用公式命令可以参考这里 x=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a} recommend 使用示例: Inline math: ∫−∞∞g(x)dx\\int_{-\\infty}^\\infty g(x) dx∫−∞∞​g(x)dx Block math: ∫−∞∞g(x)dx(4.1) \\int_{-\\infty}^\\infty g(x) dx \\quad (4.1) ∫−∞∞​g(x)dx(4.1) 引用代码 只要将代码用```包住，代码块就会被识别为代码 #include \"huffman.h\" // Postcondition: out[x].frequency > 0 void filter( /* input */ Symbol in[INPUT_SYMBOL_SIZE], /* output */ Symbol out[INPUT_SYMBOL_SIZE], /* output */ int *n) { #pragma HLS INLINE off ap_uint j = 0; for(int i = 0; i 引用图片 在行文中使用下述格式引用图片，将图片下方的备注写在[]之间 ![Figure 5.1: Part a) is a data flow graph for a 2 point DFT/FFT. Part b) shows the same compu-tation, but viewed as a butterfly structure. This is a common representation for the computation of an FFT in the digital signal processing domain.](images/2pointFFT.jpg) 文字加框 Info styling [info] For info Use this for infomation messages. Warning styling [warning] For warning Use this for warning messages. Danger styling [danger] For danger Use this for danger messages. Success styling [success] For info A high-speed computer vision application processes small video frames of 200 * 180 pixels at 10000 frames per second. This application uses a high speed sensor interfaced directly to the FPGA and requires no sync signals. How many samples per clock cycle would you attempt to process? Is this a good FPGA application? Write the nested loop structure to implement this structure using HLS. 引用术语 在行文中使用下述格式引用GLOSSARY中的术语即可 [bitstream](./GLOSSARY.md#bitstream) bitstream 引用参考文献 在行文中使用下述格式引用参考文献即可 [[45](./BIBLIOGRAPHY.md#45), [55](./BIBLIOGRAPHY.md#55)] [45, 55] Copyright © github.com/xupsh 2017 all right reserved，powered by Gitbook该文件修订时间： 2018-06-02 15:24:12 "}}